// Generated by CoffeeScript 1.10.0

/**
*
* The FomButton
*
* @class FomButton
*
* @author C.J. Morrison
*
* @since 10/12/2016
*
 */

(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.button = (function(superClass) {
    extend(button, superClass);


    /**
    *
    * ID associated with object, this is used for searching and selecting, this is required and must be unique
    *
    * @property _id
    *
    * @type {String}
    *
    * @default void 0
    *
     */

    button.prototype._id = void 0;


    /**
    *
    * Drawing Area Reference, this will reference the Drawing Area this Button is associated with.
    *
    * @property _canvasRef
    *
    * @type {DrawingArea}
    *
    * @default void 0
    *
     */

    button.prototype._canvasRef = void 0;


    /**
    *
    * An array of options with their values
    *
    * @property _options
    *
    * @type {Array}
    *
    * @default void 0
    *
     */

    button.prototype._options = void 0;


    /**
    *
    * The width of this button
    *
    * @property _width
    *
    * @type {Number}
    *
    * @default 0
    *
     */

    button.prototype._width = void 0;


    /**
    *
    * The height of this button
    *
    * @property _height
    *
    * @type {Number}
    *
    * @default 0
    *
     */

    button.prototype._height = void 0;


    /**
    *
    * Is the button currently enabled, if false the button will not accept mouse input. 
    *
    * @property _enabled
    *
    * @type {Boolean}
    *
    * @default 0
    *
     */

    button.prototype._enabled = void 0;


    /**
    *
    * Is the button currently hidden, if false the button will not accept mouse input. 
    *
    * @property _hidden
    *
    * @type {Boolean}
    *
    * @default 0
    *
     */

    button.prototype._hidden = void 0;


    /**
    *
    * The container for the button shapes icons and text of only the normal state
    *
    * @property _normalState
    *
    * @type {createJS._container}
    *
    * @default 0
    *
     */

    button.prototype._normalState = void 0;


    /**
    *
    * The container for the button shapes icons and text of only the over state
    *
    * @property _overState
    *
    * @type {createJS._container}
    *
    * @default 0
    *
     */

    button.prototype._overState = void 0;


    /**
    *
    * The container for the button shapes icons and text of only the over state
    *
    * @property _downState
    *
    * @type {createJS._container}
    *
    * @default 0
    *
     */

    button.prototype._downState = void 0;

    button.prototype._OverSound = void 0;

    button.prototype._ActivateSound = void 0;

    button.prototype._Active = void 0;


    /**
    *
    * Constructor will define the properties for this class and call Build method
    *
    * @method button
    * 
    * @param canRef - Drawing Area Reference.
    * @param options - array of options and values for this button (includes id)
    * @return void 0
    *
     */

    function button(canRef, options) {
      this.Show = bind(this.Show, this);
      this.Hide = bind(this.Hide, this);
      this.Disable = bind(this.Disable, this);
      this.Enable = bind(this.Enable, this);
      this.Update = bind(this.Update, this);
      this.isUnderMouse = bind(this.isUnderMouse, this);
      this.HandleMouseOut = bind(this.HandleMouseOut, this);
      this.HandlePressup = bind(this.HandlePressup, this);
      this.HandlePress = bind(this.HandlePress, this);
      this.HandleMouseOver = bind(this.HandleMouseOver, this);
      this.HandleAccessDeselect = bind(this.HandleAccessDeselect, this);
      this.HandleAccessSelect = bind(this.HandleAccessSelect, this);
      this.Move = bind(this.Move, this);
      this.BuildState = bind(this.BuildState, this);
      this.Build = bind(this.Build, this);
      this._canvasRef = canRef;
      this._options = options;
      this._id = options.ID;
      this._enabled = true;
      this._width = 0;
      this._height = 0;
      this._Active = false;
      this.initialize();
      this.Build();
      return;
    }


    /**
    *
    * @method Build
    *
    * Defines the buttons container and mouse events.
    *
    * @param Void 0
    * @return this
    *
     */

    button.prototype.Build = function() {
      if (this._options.overSound) {
        this._OverSound = this._options.overSound;
      } else {
        this._OverSound = "hoverSound";
      }
      if (this._options.activateSound) {
        this._ActivateSound = this._options.activateSound;
      } else {
        this._ActivateSound = "selectSound";
      }
      if (this._options.frameLoc === void 0) {
        this._options.frameLoc = [0, 0, 0];
      }
      this.BuildState('normal');
      this.BuildState('over');
      this.BuildState('down');
      this.BuildState('disabled');
      this.addEventListener('mouseover', this.HandleMouseOver);
      this.addEventListener('mouseout', this.HandleMouseOut);
      this.addEventListener('mousedown', this.HandlePress);
      this.addEventListener('pressup', this.HandlePressup);
      this._overState.visible = false;
      this._downState.visible = false;
      this._disabledState.visible = false;
      this.addChild(this._normalState);
      this.addChild(this._overState);
      this.addChild(this._downState);
      this.addChild(this._disabledState);
      if (this._options.xPos) {
        this.x = this._options.xPos;
      }
      if (this._options.yPos) {
        this.y = this._options.yPos;
      }
      if (this._options.accessPos !== void 0) {
        this._accessPos = this._options.accessPos;
      } else {
        this._accessPos = -1;
      }
      this._AccessHighlight = new createjs.Shape();
      this._AccessHighlight.graphics.setStrokeStyle(4);
      this._AccessHighlight.graphics.beginStroke("#FFFF00");
      if (this._options.useHighlightWidth && this._options.useHighlightHeight) {
        this._AccessHighlight.graphics.rect(0, 0, this._options.useHighlightWidth, this._options.useHighlightHeight);
      } else {
        this._AccessHighlight.graphics.rect(0, 0, this._width, this._height);
      }
      this._AccessHighlight.visible = false;
      this.addChild(this._AccessHighlight);
    };


    /**
    *
    * @method BuildState
    *
    * Defines the sub containers for each state of the button ("normal", "over")
    * This includes shapes, labels, and icons.
    *
    * @param state:String - that state to be built
    * @return Void 0
    *
     */

    button.prototype.BuildState = function(state) {
      var bitmap, buttonBG, color, fillColor, font, frmDat, height, i, icon, imgRes, label, len, obj, padding, radius, ref, size, togSheet, useText, width;
      this["_" + state + "State"] = new createjs.Container();
      this["_" + state + "State"]._id = state + "State";
      if (this._options.useBackground) {
        if (this._options.useBackground.constructor === String) {
          bitmap = new createjs.Bitmap(this._options.useBackground);
          toolbarBGcont.addChild(bitmap);
          this._width = bitmap.width;
          this._height = bitmap.height;
        } else if (this._options.useBackground.constructor === Object) {
          this._options.useBackground = [this._options.useBackground];
        }
        if (this._options.useBackground.constructor === Array) {
          ref = this._options.useBackground;
          for (i = 0, len = ref.length; i < len; i++) {
            obj = ref[i];
            if (obj[state + "FillColor"]) {
              fillColor = obj[state + "FillColor"];
            } else {
              fillColor = "RGB(200, 200, 200)";
            }
            if (obj.width) {
              width = obj.width;
            } else {
              width = 50;
            }
            this._width = Math.max(this._width, width);
            if (obj.height) {
              height = obj.height;
            } else {
              height = 100;
            }
            this._height = Math.max(this._height, height);
            if (obj.radius) {
              if (obj.radius.constructor === Number) {
                radius = [obj.radius, obj.radius, obj.radius, obj.radius];
              } else if (obj.radius.constructor === Array) {
                if (obj.radius.length === 2) {
                  radius = [obj.radius[0], obj.radius[0], obj.radius[1], obj.radius[1]];
                } else if (obj.radius.length === 4) {
                  radius = obj.radius;
                }
              }
            } else {
              radius = [0, 0, 0, 0];
            }
            buttonBG = new createjs.Shape;
            buttonBG.graphics.beginFill(fillColor);
            if (obj[state + "StrokeColor"] || obj[state + "StrokeWidth"]) {
              if (obj[state + "StrokeWidth"]) {
                buttonBG.graphics.setStrokeStyle(obj[state + "StrokeWidth"], "round");
              } else {
                buttonBG.graphics.setStrokeStyle(1, "round");
              }
              buttonBG.graphics.beginStroke(obj[state + "StrokeColor"]);
            }
            buttonBG.graphics.drawRoundRectComplex(0, 0, width, height, radius[0], radius[1], radius[2], radius[3]);
            this["_" + state + "State"].addChild(buttonBG);
          }
        }
      }
      if (this._options.useIcon !== void 0) {
        if (!this._options.useIcon[state + "FrameLoc"] && this._options.useIcon.frameLoc !== void 0) {
          this._options.useIcon[state + "FrameLoc"] = this._options.useIcon.frameLoc;
        }
        if (this._options.useIcon[state + "FrameLoc"] !== void 0) {
          imgRes = preload.getResult(this._options.useIcon.resource);
          frmDat = preload.getItem(this._options.useIcon.resource).dataset.frameData;
          if (this._options.useIcon[state + "FrameLoc"].constructor === Number) {
            this._options.useIcon[state + "FrameLoc"] = [this._options.useIcon[state + "FrameLoc"], this._options.useIcon[state + "FrameLoc"]];
          }
          togSheet = new createjs.SpriteSheet({
            "images": [imgRes],
            "frames": frmDat,
            "animations": {
              "norm": [this._options.useIcon[state + "FrameLoc"][0]],
              "over": [this._options.useIcon[state + "FrameLoc"][1]],
              "down": [this._options.useIcon[state + "FrameLoc"][2]]
            }
          });
          icon = new createjs.Sprite(togSheet, "norm");
          icon.width = frmDat[this._options.useIcon[state + "FrameLoc"][0]][2];
          icon.height = frmDat[this._options.useIcon[state + "FrameLoc"][0]][3];
        } else if (this._options.useIcon.resource.constructor === HTMLImageElement) {
          icon = new createjs.Bitmap(this._options.useIcon.resource);
          icon.width = icon.image.width;
          icon.height = icon.image.height;
        } else if (this._options.useIcon.resource.constructor === createjs.Bitmap) {
          icon = this._options.useIcon.resource.clone();
          icon.width = icon.image.width * icon.scaleX;
          icon.height = icon.image.height * icon.scaleY;
        }
        if (!icon) {
          return;
        }
        this._width = Math.max(this._width, icon.width);
        this._height = Math.max(this._height, icon.height);
        if (this._options.useIcon.position === "left") {
          icon.x = 8;
          icon.y = (this._height / 2) - (icon.height / 2);
        } else if (this._options.useIcon.position === "right") {
          icon.x = this._width - icon.width - 8;
          icon.y = (this._height - icon.height) / 2;
        } else if (this._options.useIcon.position === "center") {
          icon.x = (this._width - icon.width) / 2;
          icon.y = (this._height - icon.height) / 2;
        }
        if (this._options.useIcon.scale) {
          icon.scaleX = this._options.useIcon.scale;
          icon.scaleY = this._options.useIcon.scale;
        }
        this["_" + state + "State"].addChild(icon);
      }
      if (this._options.label) {
        if (!this._options.labelOptions) {
          this._options.labelOptions = {};
        }
        if (this._options.labelOptions.color) {
          color = this._options.labelOptions.color;
        } else {
          color = "#000";
        }
        if (this._options.labelOptions.size) {
          size = this._options.labelOptions.size;
        }
        if (this._options.labelOptions.font) {
          font = this._options.labelOptions.font;
        }
        if (this._options.labelOptions.padding) {
          padding = parseInt(this._options.labelOptions.padding);
        } else {
          padding = 0;
        }

        /*
        if not obj["#{state}AltText"]
           useText = @_options.label
        else
           useText = obj["#{state}AltText"]
         */
        useText = this._options.label;
        label = new createjs.Text(useText, "bold " + size + "px " + font, color);
        if (this._options.labelOptions.lineWidth) {
          label.lineWidth = this._options.labelOptions.lineWidth;
        }
        if (!this._options.useIcon) {
          label.textAlign = "center";
          label.y = 2 + padding;
          label.x = this._width / 2;
        } else if (this._options.useIcon.position === "left") {
          label.textAlign = "left";
          label.y = 2 + padding;
          label.x = icon.width + icon.x + 7 + padding;
        } else {
          label.textAlign = "left";
          label.y = 2 + padding;
          label.x = 7 + padding;
        }
        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
          label.y += 3;
        }
        this["_" + state + "State"].addChild(label);
      }
    };


    /**
    *
    * @method Move
    *
    * Moves Button to desired X and Y coordinates
    *
    * @param x:Number the X position the button will be moved to
    * @param y:Number the Y position the button will be moved to
    * @return Void 0
    *
     */

    button.prototype.Move = function(x, y) {
      this.x = x;
      this.y = y;
    };

    button.prototype.HandleAccessSelect = function() {
      this._AccessHighlight.visible = true;
      if (this._options.onFocus) {
        this._options.onFocus(this);
      }
      return this.HandleMouseOver();
    };

    button.prototype.HandleAccessDeselect = function() {
      this._AccessHighlight.visible = false;
      if (this._options.onBlur) {
        this._options.onBlur(this);
      }
      return this.HandleMouseOut();
    };


    /**
    *
    * @method HandleMouseOver
    *
    * Event function called when mouse is over the button. this will change the state to over
    *
    * @param e:Event Mouse event
    * @return Void 0
    *
     */

    button.prototype.HandleMouseOver = function(e) {
      if (!(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) {
        if (this._enabled && !this._hidden && !this._Active && !this._overState.visible) {
          this._overState.visible = true;
          createjs.Sound.stop();
          createjs.Sound.play(this._OverSound);
          if (this._options.onOver) {
            this._options.onOver(this);
          }
        }
      }
    };

    button.prototype.HandlePress = function(e) {
      var cPrm, i, len, newParam, prm, ref, useParams;
      if (this._enabled && !this._hidden) {
        this._overState.visible = false;
        this._downState.visible = true;
        createjs.Sound.stop();
        createjs.Sound.play(this._ActivateSound);
        if (!this._options.onActivateParams || this._options.onActivateParams.constructor !== Array) {
          useParams = [
            {
              data: this._options.onActivateParams,
              caller: this
            }
          ];
        } else {
          newParam = [];
          ref = this._options.onActivateParams;
          for (i = 0, len = ref.length; i < len; i++) {
            prm = ref[i];
            cPrm = prm.valueOf();
            if (cPrm.constructor !== Object) {
              cPrm = {
                data: cPrm
              };
            }
            cPrm.caller = this;
            newParam.push(cPrm);
          }
          useParams = newParam;
        }
        this._Active = true;
        if (this._options.onActivate) {
          this._options.onActivate();
        }
      }
    };

    button.prototype.HandlePressup = function(e) {
      if (this._enabled && !this._hidden) {
        this._downState.visible = false;
      }
      this._Active = false;
    };


    /**
    *
    * @method HandleMouseOut
    *
    * Event function called when mouse leaves the button. this will change the state to normal
    *
    * @param e:Event Mouse event
    * @return Void 0
    *
     */

    button.prototype.HandleMouseOut = function(e) {
      if (this._enabled && this._overState.visible) {
        if ((e && e.stageX && !this.isUnderMouse(e.stageX, e.stageY)) || !e) {
          this._overState.visible = false;
          if (this._options.onOut) {
            this._options.onOut(this);
          }
        }
      }
    };

    button.prototype.isUnderMouse = function(mousePosX, mousePosY) {
      var checkParents, i, len, ref, sc;
      checkParents = (function(_this) {
        return function(parObj) {
          if (parObj === _this) {
            return true;
          } else if (parObj.parent) {
            return checkParents(parObj.parent);
          } else {
            return false;
          }
        };
      })(this);
      ref = this.stage.getObjectsUnderPoint(mousePosX, mousePosY);
      for (i = 0, len = ref.length; i < len; i++) {
        sc = ref[i];
        if (sc === this) {
          return true;
        } else if (sc.parent && checkParents(sc.parent)) {
          return true;
        }
      }
      return false;
    };

    button.prototype.Update = function() {
      if (this._enabled && this._Active && this._options.whileActive) {
        return this._options.whileActive();
      }
    };


    /**
    *
    * @method Enable
    *
    * Enables the button
    *
    * @param Void 0
    * @return Void 0
    *
     */

    button.prototype.Enable = function() {
      this._enabled = true;
      if (!this._hidden) {
        this._disabledState.visible = false;
        this._downState.visible = false;
        this._normalState.visible = true;
      }
    };


    /**
    *
    * @method Disable
    *
    * Disables the button
    *
    * @param Void 0
    * @return Void 0
    *
     */

    button.prototype.Disable = function() {
      this._enabled = false;
      if (!this._hidden) {
        this._normalState.visible = false;
        this._downState.visible = false;
        this._disabledState.visible = true;
      }
    };


    /**
    *
    * @method Hide
    *
    * Hides the button
    *
    * @param Void 0
    * @return Void 0
    *
     */

    button.prototype.Hide = function() {
      this._hidden = true;
      this._normalState.visible = false;
      this._overState.visible = false;
      this._downState.visible = false;
      this._disabledState.visible = false;
    };


    /**
    *
    * @method Show
    *
    * Shows the button
    *
    * @param Void 0
    * @return Void 0
    *
     */

    button.prototype.Show = function() {
      this._hidden = false;
      if (this._enabled) {
        this._normalState.visible = true;
      } else {
        this._disabledState.visible = true;
      }
    };

    return button;

  })(createjs.Container);

}).call(this);
