// Generated by CoffeeScript 1.10.0

/**
*
* The DaToolbar
*
* @class DaToolbarToggle
*
* @author C.J. Morrison
*
* @since 10/12/2016
*
 */

(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.DaToolbarToggle = (function() {

    /**
    *
    * ID associated with object, this is used for searching and selecting, this is required and must be unique
    *
    * @property _id
    *
    * @type {String}
    *
    * @default void 0
    *
     */
    DaToolbarToggle.prototype._id = void 0;


    /**
    *
    * Drawing Area Reference, this will reference the Drawing Area this modal is associated with.
    *
    * @property _daRef
    *
    * @type {DrawingArea}
    *
    * @default void 0
    *
     */

    DaToolbarToggle.prototype._daRef = void 0;


    /**
    *
    * An array of options with their values
    *
    * @property _options
    *
    * @type {Array}
    *
    * @default []
    *
     */

    DaToolbarToggle.prototype._options = void 0;


    /**
    *
    * True if the toggle has been selected 
    *
    * @property _active
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DaToolbarToggle.prototype._active = void 0;


    /**
    *
    * A container for all of the elements of the toggle 
    * this is what will be added as a child to the drawing area.
    *
    * @property _container
    *
    * @type {CreateJS.Container}
    *
    * @default Void 0
    *
     */

    DaToolbarToggle.prototype._container = void 0;


    /**
    *
    * The CreateJS sprite object which visually represents the toggle 
    *
    * @property _sprite
    *
    * @type {CreateJS.sprite}
    *
    * @default new
    *
     */

    DaToolbarToggle.prototype._sprite = void 0;


    /**
    *
    * A referance to the flyout object that is acciated with this toggle (the flyout that is activated upon activating the toggle)
    *
    * @property _flyoutRef
    *
    * @type {CreateJS.sprite}
    *
    * @default new
    *
     */

    DaToolbarToggle.prototype._flyoutRef = void 0;


    /**
    *
    * The width of this button
    *
    * @property _width
    *
    * @type {Number}
    *
    * @default 0
    *
     */

    DaToolbarToggle.prototype._width = void 0;


    /**
    *
    * The height of this button
    *
    * @property _height
    *
    * @type {Number}
    *
    * @default 0
    *
     */

    DaToolbarToggle.prototype._height = void 0;


    /**
    *
    * Is the button currently enabled, if false the button will not accept mouse input. 
    *
    * @property _enabled
    *
    * @type {Boolean}
    *
    * @default 0
    *
     */

    DaToolbarToggle.prototype._enabled = void 0;


    /**
    *
    * Constructor will define the properties for this class and call Build method
    *
    * @method DaToolbarToggle
    * 
    * @param tbRef - ToolbarManager referance.
    * @param options - list of options and values for this toggle
    * @return void 0
    *
     */

    function DaToolbarToggle(tbRef, options) {
      this.GetActiveSubtoggle = bind(this.GetActiveSubtoggle, this);
      this.Disable = bind(this.Disable, this);
      this.Enable = bind(this.Enable, this);
      this.UseAltFrames = bind(this.UseAltFrames, this);
      this.HandleClick = bind(this.HandleClick, this);
      this.HandleMouseOut = bind(this.HandleMouseOut, this);
      this.HandleMouseOver = bind(this.HandleMouseOver, this);
      this.Move = bind(this.Move, this);
      this.AssessDimentions = bind(this.AssessDimentions, this);
      this.Deactivate = bind(this.Deactivate, this);
      this.Activate = bind(this.Activate, this);
      this.Build = bind(this.Build, this);
      this._tbRef = tbRef;
      this._options = options;
      this._id = options.id;
      this._active = false;
      this._enabled = true;
      this.Build();
      return;
    }


    /**
    *
    * Builds the sprite and events, will activate if activation on initialization is required.
    *
    * @method Build
    *
    * @param void 0 
    * @return this
    *
    *
     */

    DaToolbarToggle.prototype.Build = function(rebuild) {
      var frmDat, imgRes, togSheet;
      if (this._options.frameLoc === void 0) {
        this._options.frameLoc = [0, 0, 0];
      }
      imgRes = this._tbRef._daManagerRef._loadedAssets.getResult(this._options.resource);
      frmDat = JSON.parse(imgRes.dataset.frameData);
      togSheet = new createjs.SpriteSheet({
        "images": [imgRes],
        "frames": frmDat,
        "animations": {
          "norm": [this._options.frameLoc[0]],
          "over": [this._options.frameLoc[1]],
          "activeNorm": [this._options.frameLoc[2]],
          "activeOver": [this._options.frameLoc[2]]
        }
      });
      this.AssessDimentions(frmDat);
      if (!this._container) {
        this._container = new createjs.Container;
        this._container.addEventListener('mouseover', this.HandleMouseOver);
        this._container.addEventListener('mouseout', this.HandleMouseOut);
        this._container.addEventListener('click', this.HandleClick);
      }
      if (this._sprite) {
        this._container.removeChild(this._sprite);
      }
      this._sprite = new createjs.Sprite(togSheet, "norm");
      this._container.addChild(this._sprite);
      if ((this._options.initActive && !rebuild) || this._active) {
        this.Activate(true);
      }
      return this;
    };


    /**
    *
    * Called when the toggle is selected by being clicked on or other means. 
    * This will change the visual state of the toggle, if there is a flyout for the toggle it will be opened if not the associated action will trigger
    * and the toolbar will close.
    *
    * @method Activate
    *
    * @param asInit:boolean - is this being activated on initialization?
    * @param asParentOpened:boolean - is this being activated as a result of a parent toggle opening a flyout of which this toggle is contained in
    * @return void 0 
    *
    *
     */

    DaToolbarToggle.prototype.Activate = function(asInit, asParentOpened) {
      var aa, cPrm, i, len, newParam, prm, ref, useParams;
      this._active = true;
      this._sprite.gotoAndStop("activeOver");
      if (!asInit) {
        if (!asParentOpened) {
          createjs.Sound.play("def_select");
        }
        if (!this._options.isSubToggle && this._flyoutRef) {
          this._flyoutRef.Popout(this._flyoutRef);
        } else if (!asParentOpened) {
          this._tbRef._daRef.DeactivateScreenUI();
        }
        if (!this._options.onActivateParams || this._options.onActivateParams.constructor !== Array) {
          useParams = [
            {
              data: this._options.onActivateParams,
              caller: this
            }
          ];
        } else {
          newParam = [];
          ref = this._options.onActivateParams;
          for (i = 0, len = ref.length; i < len; i++) {
            prm = ref[i];
            cPrm = prm.valueOf();
            if (cPrm.constructor !== Object) {
              cPrm = {
                data: cPrm
              };
            }
            cPrm.caller = this;
            newParam.push(cPrm);
          }
          useParams = newParam;
        }
        if (this._options.onActivate) {
          if (this._options.onActivate.constructor === String) {
            this._tbRef._daManagerRef.CustomEventCall(this._options.onActivate, this._tbRef._daRef, useParams);
          } else if (this._options.onActivate.constructor === Array) {
            aa = 0;
            while (aa < this._options.onActivate.length) {
              this._tbRef._daManagerRef.CustomEventCall(this._options.onActivate[aa], this._tbRef._daRef, useParams[aa]);
              aa++;
            }
          }
        }
        if (this.GetActiveSubtoggle()) {
          this.GetActiveSubtoggle().Activate(false, true);
        }
        return this._tbRef._daRef.HandleInternalEvent("onToggleActivated", {
          target: this
        });
      }
    };


    /**
    *
    * Called when a different toggle in the same cluster is selected or if forced by a stage action.
    * if there is a flyout with this toggle it will close. some toggles may have an associated deactivate event.
    *
    * @method Deactivate
    *
    * @param void 0 
    * @return void 0 
    *
     */

    DaToolbarToggle.prototype.Deactivate = function() {
      var cPrm, da, i, len, newParam, prm, ref, results, useParams;
      this._active = false;
      this._sprite.gotoAndStop('norm');
      if (!this._options.isSubToggle) {
        if (this._flyoutRef) {
          this._flyoutRef.PopIn(this._flyoutRef);
        }
      }
      if (!this._options.onDeactivateParams || this._options.onDeactivateParams.constructor !== Array) {
        useParams = [
          {
            data: this._options.onDeactivateParams,
            caller: this
          }
        ];
      } else {
        newParam = [];
        ref = this._options.onDeactivateParams;
        for (i = 0, len = ref.length; i < len; i++) {
          prm = ref[i];
          cPrm = prm.valueOf();
          if (cPrm.constructor !== Object) {
            cPrm = {
              data: cPrm
            };
          }
          cPrm.caller = this;
          newParam.push(cPrm);
        }
        useParams = newParam;
      }
      if (this._options.onDeactivate) {
        if (this._options.onDeactivate.constructor === String) {
          return this._tbRef._daManagerRef.CustomEventCall(this._options.onDeactivate, this._tbRef._daRef, useParams);
        } else if (this._options.onDeactivate.constructor === Array) {
          da = 0;
          results = [];
          while (da < this._options.onDeactivate.length) {
            this._tbRef._daManagerRef.CustomEventCall(this._options.onDeactivate[da], this._tbRef._daRef, useParams);
            results.push(da++);
          }
          return results;
        }
      }
    };


    /**
    *
    * since CreateJS sprites do not have a width or height property natively this will assess the frame data to set the width and height of this toggle appropriately
    *
    * @method Deactivate
    *
    * @param frameData:array - contains the rect values of each frame in the sprite sheet.
    * @return void 0 
    *
     */

    DaToolbarToggle.prototype.AssessDimentions = function(frameData) {
      var f, heights, i, len, ref, widths;
      widths = [];
      heights = [];
      ref = this._options.frameLoc;
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        widths.push(frameData[f][2]);
        heights.push(frameData[f][3]);
      }
      this._width = Math.max.apply(Math, widths);
      this._height = Math.max.apply(Math, heights);
    };


    /**
    *
    * @method Move
    *
    * Moves Toggle to desired X and Y coordinates
    *
    * @param x:Number the X position the Toggle will be moved to
    * @param y:Number the Y position the Toggle will be moved to
    * @return Void 0
    *
     */

    DaToolbarToggle.prototype.Move = function(x, y) {
      this._container.x = x;
      return this._container.y = y;
    };


    /**
    *
    * @method HandleMouseOver
    *
    * changes the state of the sprite when the mouse is over it, sets the tooltip to its position.
    *
    * @param e:Event the mouse over event.
    * @return Void 0
    *
     */

    DaToolbarToggle.prototype.HandleMouseOver = function(e) {
      var glob, target;
      if (this._enabled) {
        if (this._active) {
          this._sprite.gotoAndStop("activeOver");
        } else {
          this._sprite.gotoAndStop('over');
        }
        if (this._options.useToolTip && !this._active && !this._tbRef._daRef._toolTipLock) {
          target = this._tbRef._daRef._toolTip;
          glob = this._sprite.localToGlobal(0, 0);
          target.Show();
          target.SetText(this._id);
          this._tbRef._daRef._toolTip.Move(glob.x + this._width + 10, glob.y + (this._height / 2));
        }
      }
    };


    /**
    *
    * @method HandleMouseOut
    *
    * changes the state of the sprite when the mouse leaves it, hides the tooltip.
    *
    * @param e:Event the mouse  event.
    * @return Void 0
    *
     */

    DaToolbarToggle.prototype.HandleMouseOut = function(e) {
      var target;
      if (this._enabled) {
        if (this._active) {
          this._sprite.gotoAndStop("activeNorm");
        } else {
          this._sprite.gotoAndStop('norm');
        }
        if (this._options.useToolTip && !this._tbRef._daRef._toolTipLock) {
          target = this._tbRef._daRef._toolTip;
          target.Hide();
        }
      }
    };


    /**
    *
    * @method HandleClick
    *
    * activates the toggle and hides the tooltip, also handles all clustered toggles forcing any active toggle in the cluster to deactivate.
    *
    * @param e:Event the mouse click event.
    * @return Void 0
    *
     */

    DaToolbarToggle.prototype.HandleClick = function(e) {
      var i, j, len, len1, ref, ref1, target, tog;
      if (this._enabled) {
        if (this._options.isSubToggle) {
          ref = this._options.flyoutRef.subToggles;
          for (i = 0, len = ref.length; i < len; i++) {
            tog = ref[i];
            if (tog !== this) {
              tog.Deactivate();
            }
          }
        } else {
          if (this._options.clustered) {
            ref1 = this._tbRef._toggles;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              tog = ref1[j];
              if (tog._options.clusterId === this._options.clusterId && tog !== this) {
                tog.Deactivate();
              }
            }
          }
        }
        if (this._options.useToolTip) {
          target = this._tbRef._daRef._toolTip;
          target.Hide();
        }
        this.Activate();
      }
    };


    /**
    *
    * @method UseAltFrames
    *
    * Sets the tooggle to use an alternative icon set.
    *
    * @param altID: the provided id of the alternate frame locations in the altFrameLoc option
    * @return Void 0
    *
     */

    DaToolbarToggle.prototype.UseAltFrames = function(altID) {
      if (this._options.altFrameLocs && this._options.altFrameLocs[altID]) {
        this._options.frameLoc = this._options.altFrameLocs[altID];
        return this.Build(true);
      } else {
        return this._tbRef._daManagerRef.d2log("UseAltFrames passed unknown frame id " + altID + ", in object " + this._id);
      }
    };


    /**
    *
    * @method Enable
    *
    * enables all the toggle to work with mouse events
    *
    * @param void 0
    * @return void 0
    *
     */

    DaToolbarToggle.prototype.Enable = function() {
      return this._enabled = true;
    };


    /**
    *
    * @method Disable
    *
    * disables the toggle from working with mouse events
    *
    * @param void 0
    * @return void 0
    *
     */

    DaToolbarToggle.prototype.Disable = function() {
      return this._enabled = false;
    };


    /**
    *
    * @method GetActiveSubtoggle
    *
    * if the toggle has sub toggles associated with it this will get the active one.
    *
    * @param void 0
    * @return DaToolbarToggle | false if none available
    *
     */

    DaToolbarToggle.prototype.GetActiveSubtoggle = function() {
      var i, len, ref, st;
      if (this._flyoutRef) {
        ref = this._flyoutRef.subToggles;
        for (i = 0, len = ref.length; i < len; i++) {
          st = ref[i];
          if (st === this) {
            return false;
          } else {
            if (st._active) {
              return st;
            }
          }
        }
      }
      return false;
    };

    return DaToolbarToggle;

  })();

}).call(this);
