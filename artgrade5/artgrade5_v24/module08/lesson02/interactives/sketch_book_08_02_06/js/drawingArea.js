// Generated by CoffeeScript 1.10.0

/**
*
* The DrawingArea Class contains all of the main features and properties for the common drawing area
*
* @class DrawingArea
*
* @author C.J. Morrison
*
* @since 10/12/2016
*
 */

(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.DrawingArea = (function() {

    /**
    *
    * Bool if the object is ready
    *
    * @property _initalized
    *
    * @type {Boolean}
    *
    * @default false
    *
     */
    DrawingArea.prototype._initalized = void 0;


    /**
    *
    * Bool if the object is in a preloading state with an active daPreload object
    *
    * @property _preInitalized
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DrawingArea.prototype._preInitalized = void 0;


    /**
    *
    * The id attribute of the canvas tag associated with this object
    *
    * @property _domID
    *
    * @type {String}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._domID = void 0;

    DrawingArea.prototype._tttlMod = void 0;


    /**
    *
    * The CreateJS Stage object that will be applied to the canvas
    *
    * @property _cjsStage
    *
    * @type {createjs.Stage}
    *
    * @default new
    *
     */

    DrawingArea.prototype._cjsStage = void 0;


    /**
    *
    * A referance to the DrawingAreaManager
    *
    * @property _managerRef
    *
    * @type {DrawingAreaManager}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._managerRef = void 0;


    /**
    *
    * A reference to the canvas tag associated with this object
    *
    * @property _canvRef
    *
    * @type {canvas}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._canvRef = void 0;


    /**
    *
    * Holds the Language data for the Drawing Areas default context
    *
    * @property _langSet
    *
    * @type {String}
    *
    * @default "EN"
    *
     */

    DrawingArea.prototype._langSet = void 0;


    /**
    *
    * Holds the DaPreload object this area may use.
    *
    * @property _preloadObj
    *
    * @type {DaPreload}
    *
    * @default new
    *
     */

    DrawingArea.prototype._preloadObj = void 0;


    /**
    *
    * Defines the type of drawing area this will be
    *
    * @property _daModeSet
    *
    * @type {String}
    *
    * @default "standard"
    *
     */

    DrawingArea.prototype._daModeSet = void 0;


    /**
    *
    * Holds the coordinates data for the drawing
    *
    * @property _coordinates
    *
    * @type {Object}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._coordinates = void 0;


    /**
    *
    * Holds the distance between the previous point during a drawn update and the current, used to create a trailing effect.
    *
    * @property _oldDistFact
    *
    * @type {Number}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._oldDistFact = void 0;


    /**
    *
    * Contains various options and values related to this drawing area
    *
    * @property _DrawOptions
    *
    * @type {Object}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._DrawOptions = void 0;


    /**
    *
    * Contains options and values regarding how this Drawing area will react to changes in the window size
    *
    * @property _AdaptiveOptions
    *
    * @type {Object}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._AdaptiveOptions = void 0;


    /**
    *
    * Contains the various layers (in Z order) of the Create JS containers that will be on the CreateJS stage
    *
    * @property _displayLayers
    *
    * @type {CreateJS.Container}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._displayLayers = void 0;


    /**
    *
    * Reference to the DaToolbarManager that will be used by this Drawing Area.
    *
    * @property _toolbarManagerRef
    *
    * @type {DaToolbarManager}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._toolbarManagerRef = void 0;


    /**
    *
    * set true if the mouse is down or tap is in progress on the drawing area. 
    *
    * @property _isDrawing
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DrawingArea.prototype._isDrawing = void 0;


    /**
    *
    * Contains all of the DaButton object which appear on the Drawing Area (this excludes buttons in modals)
    *
    * @property _buttons
    *
    * @type {Array}
    *
    * @default []
    *
     */

    DrawingArea.prototype._buttons = void 0;


    /**
    *
    * Contains all of the DaModal objects that are used in this Drawing Area
    *
    * @property _modals
    *
    * @type {Array}
    *
    * @default []
    *
     */

    DrawingArea.prototype._modals = void 0;


    /**
    *
    * Contains all of the DaWalkthroughs objects that are used in this Drawing Area
    *
    * @property _walkthroughs
    *
    * @type {Array}
    *
    * @default []
    *
     */

    DrawingArea.prototype._walkthroughs = void 0;

    DrawingArea.prototype._walkthroughRequested = void 0;


    /**
    *
    * When true a Modal is open and all interactive behind it will be disabled.
    *
    * @property _modalLock
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DrawingArea.prototype._modalLock = void 0;


    /**
    *
    * When true interactive objects on the drawing area will be disabled.
    *
    * @property _modalLock
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DrawingArea.prototype._enabled = void 0;


    /**
    *
    * disables input while load actions occur, this get overridden after 3 ticks if load fails. This is used to ensure a graceful
    * fail during the Baking process.
    *
    * @property _loadLock
    *
    * @type {Number}
    *
    * @default 0
    *
     */

    DrawingArea.prototype._loadLock = void 0;


    /**
    *
    * Disables input for 3 ticks after a stamp is placed. this prevents issues with the baking process.
    *
    * @property _stampLock
    *
    * @type {Number}
    *
    * @default 0
    *
     */

    DrawingArea.prototype._stampLock = void 0;


    /**
    *
    * Holds Draw instructions the have been removed by the undo process, these are used with Redo
    *
    * @property _undoMemory
    *
    * @type {Array}
    *
    * @default []
    *
     */

    DrawingArea.prototype._undoMemory = void 0;


    /**
    *
    * Prevents multiple clears in a row, true when a clear has occurred, clears cannot process when true.
    *
    * @property _clearFlag
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DrawingArea.prototype._clearFlag = void 0;


    /**
    *
    * A object of events that this Drawing area can trigger, as keys. The associated events are stored as arrays in the values.
    *
    * @property _events
    *
    * @type {Object}
    *
    * @default void 0
    *
     */

    DrawingArea.prototype._events = void 0;


    /**
    *
    * Stores the DaTooltip object used by this Drawing Area
    *
    * @property _toolTip
    *
    * @type {DaToolTip}
    *
    * @default new
    *
     */

    DrawingArea.prototype._toolTip = void 0;


    /**
    *
    * prevents main tooltip from appearing (usually a walkthrough in progress)
    *
    * @property _toolTipLock
    *
    * @type {Boolean}
    *
    * @default false
    *
     */

    DrawingArea.prototype._toolTipLock = void 0;


    /**
    *
    * Holds the StrokeImageData where needed
    *
    * @property _eraseStrokeImage
    *
    * @type {image}
    *
    * @default new
    *
     */

    DrawingArea.prototype._eraseStrokeImage = void 0;

    DrawingArea.prototype._initCanvasDimentions = void 0;

    DrawingArea.prototype._globalScale = void 0;

    DrawingArea.prototype._playScreenCont = void 0;

    DrawingArea.prototype._initOptions = void 0;

    DrawingArea.prototype._mdFlag = void 0;


    /**
    *
    * Constructor will define the properties for this class
    *
    * @method DrawingArea
    *
     */

    function DrawingArea(dID, manRef, ops) {
      this.OpenSlideInstructions = bind(this.OpenSlideInstructions, this);
      this.SlideNav = bind(this.SlideNav, this);
      this.HandleInternalEvent = bind(this.HandleInternalEvent, this);
      this.RequestRedo = bind(this.RequestRedo, this);
      this.RequestUndo = bind(this.RequestUndo, this);
      this.PrintImage = bind(this.PrintImage, this);
      this.DownloadImage = bind(this.DownloadImage, this);
      this.GetImageDataURl = bind(this.GetImageDataURl, this);
      this.DestroyCaptureStage = bind(this.DestroyCaptureStage, this);
      this.PrepCaptureStage = bind(this.PrepCaptureStage, this);
      this.Clear = bind(this.Clear, this);
      this.BuildStamp = bind(this.BuildStamp, this);
      this.GetDaObjectById = bind(this.GetDaObjectById, this);
      this.HandleResizeEvent = bind(this.HandleResizeEvent, this);
      this.Update = bind(this.Update, this);
      this.BakeDrawLayers = bind(this.BakeDrawLayers, this);
      this.HandleMouseUp = bind(this.HandleMouseUp, this);
      this.HandleMouseDown = bind(this.HandleMouseDown, this);
      this.HandleMouseMove = bind(this.HandleMouseMove, this);
      this.getClonedImage = bind(this.getClonedImage, this);
      this.ParseOptions = bind(this.ParseOptions, this);
      this.DeactivateScreenUI = bind(this.DeactivateScreenUI, this);
      this.ActivateScreenUI = bind(this.ActivateScreenUI, this);
      this.DrawScreenUI = bind(this.DrawScreenUI, this);
      this.ModalUnlock = bind(this.ModalUnlock, this);
      this.ModalLock = bind(this.ModalLock, this);
      this.CloseModal = bind(this.CloseModal, this);
      this.OpenModal = bind(this.OpenModal, this);
      this.GetWalkthrough = bind(this.GetWalkthrough, this);
      this.GetModal = bind(this.GetModal, this);
      this.PreloadDataResoucres = bind(this.PreloadDataResoucres, this);
      this.BuildModals = bind(this.BuildModals, this);
      this.BuildWalkthroughs = bind(this.BuildWalkthroughs, this);
      this.DrawInteractiveMask = bind(this.DrawInteractiveMask, this);
      this.AppendButtons = bind(this.AppendButtons, this);
      this.GetTttl = bind(this.GetTttl, this);
      this.ChangeBackground = bind(this.ChangeBackground, this);
      this.LoadBackground = bind(this.LoadBackground, this);
      this.preloadSlideResources = bind(this.preloadSlideResources, this);
      this.Init = bind(this.Init, this);
      this.PreInit = bind(this.PreInit, this);
      this._initalized = false;
      this._initOptions = ops.valueOf();
      this._preInitalized = false;
      this._domID = dID;
      if (manRef) {
        this._managerRef = manRef;
      }
      this._enabled = true;
      this._loadLock = 0;
      this._stampLock = 0;
      this._undoMemory = [];
      this._buttons = [];
      this._modals = [];
      this._walkthroughs = [];
      this._walkthroughRequested = false;
      this._toolTipLock = false;
      this._clearFlag = false;
      this._mdFlag = false;
      this._isDrawing = false;
      this._usingSlidesData = false;
      this._currentSlideIndex = 0;
      this._events = {
        "onPreInit": void 0,
        "onReady": void 0,
        "whileDraw": void 0,
        "drawStart": void 0,
        "drawEnd": void 0,
        "onToggleActivated": void 0,
        "onButtonClick": void 0,
        "onSaveReq": void 0,
        "onSaveEnd": void 0,
        "onUndo": void 0,
        "onUndoStart": void 0,
        "onUndoEnd": void 0,
        "onRedo": void 0,
        "onSlideOpen": void 0
      };
      this._DrawOptions = {
        size: 2,
        color: "#000000",
        bg_color: "#FFFFFF",
        penType: "round",
        stampSelection: "circle",
        fade: 0,
        eraseMode: false,
        stampMode: false,
        cropRect: void 0
      };
      this._AdaptiveOptions = {
        adaptive: false
      };

      /*
      @ParseOptions(ops, ()=>
         @Init()
         )
       */
      return;
    }


    /**
    *
    * @method PreInit
    *
    * Builds the CreateJS stage and the Preloader if one is required.
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.PreInit = function() {
      this._cjsStage = new createjs.Stage(this._domID);
      this._canvRef = document.getElementById(this._domID);
      this._cjsStage.enableDOMEvents(true);
      this._cjsStage.enableMouseOver(this._managerRef._fpsRendering);
      createjs.Touch.enable(this._cjsStage, true, false);
      this._initCanvasDimentions = {
        width: this._canvRef.width,
        height: this._canvRef.height
      };
      this._playScreenCont = new createjs.Container();
      this._playScreenCont.setBounds(0, 0, this._initCanvasDimentions.width, this._initCanvasDimentions.height);
      this._globalScale = 1;
      this._preInitalized = true;
      if (this._initOptions.events.onPreInit) {
        this._events.onPreInit = this._initOptions.events.onPreInit;
        return this.HandleInternalEvent("onPreInit");
      }
    };


    /**
    *
    * @method Init
    *
    * Takes the provided options to build the various display layers and interactive elements.
    *
    * @param ops:Object - options defined when setting this drawing area.
    * @return Void 0
    *
     */

    DrawingArea.prototype.Init = function(ops) {
      this.ParseOptions(ops, (function(_this) {
        return function() {
          var finalInitSteps, oldX, oldY, postBGload;
          _this._cjsStage.addChild(_this._playScreenCont);
          _this._preloadObj = new window.DaPreloader(_this, {
            "id": _this._domID + "_preloader"
          });
          _this._cjsStage.addChild(_this._preloadObj._container);
          if (!_this._preInitalized) {
            _this._cjsStage = new createjs.Stage(_this._domID);
            _this._canvRef = document.getElementById(_this._domID);
          }
          oldX = 0;
          oldY = 0;
          _this._coordinates = {
            oldX: 0,
            oldY: 0
          };
          if (_this._displayLayers.background && _this._displayLayers.background.constructor === String) {
            _this._displayLayers.background = new createjs.Bitmap(_this._displayLayers.background);
            _this._cjsStage.addChild(_this._displayLayers.background);
          }
          postBGload = function() {
            var fullLockScreen, fullLockText;
            _this._displayLayers.interactiveArea = new createjs.Shape();
            if (_this._displayLayers.bgMask) {
              _this._displayLayers.interactiveArea.alpha = .01;
            }
            _this._cjsStage.addChild(_this._displayLayers.interactiveArea);
            _this._displayLayers.interactiveArea.on("pressmove", _this.HandleMouseMove);
            _this._displayLayers.interactiveArea.on("mousedown", _this.HandleMouseDown);
            _this._displayLayers.interactiveArea.on("pressup", _this.HandleMouseUp);
            document.addEventListener("mouseout", _this.HandleMouseUp);
            _this._displayLayers.histLayer = new createjs.Bitmap(_this._managerRef._loadedAssets.getResult('nullPixel'));
            _this._cjsStage.addChild(_this._displayLayers.histLayer);
            if (_this._daModeSet === 'display') {
              _this._displayLayers.drawContainer = _this._DrawOptions.displaySourceRef._displayLayers.drawContainer;
              _this._cjsStage.addChild(_this._displayLayers.drawContainer);
            } else {
              _this._displayLayers.drawContainer = new createjs.Container;
              if (_this._daModeSet !== 'reveal' && _this._daModeSet !== 'control') {
                _this._cjsStage.addChild(_this._displayLayers.drawContainer);
              }
              if (_this._DrawOptions.useCaching) {
                _this._displayLayers.drawContainer.cache(0, 0, _this._canvRef.width, _this._canvRef.height);
              }
            }
            if (_this._displayLayers.overlay && _this._displayLayers.overlay.constructor === String) {
              if (_this._displayLayers.overlay.indexOf("?_=") === -1) {
                _this._displayLayers.overlay = _this._managerRef.randomQuery(_this._displayLayers.overlay);
              }
              _this._displayLayers.overlay = new createjs.Bitmap(_this._displayLayers.overlay);
              _this._cjsStage.addChild(_this._displayLayers.overlay);
            }
            _this.DrawInteractiveMask(0, 0, _this._cjsStage.canvas.width, _this._cjsStage.canvas.height);
            if (_this._AdaptiveOptions.adaptive) {
              _this._canvRef.parentElement.className += " daAdaptive";
              _this.HandleResizeEvent();
            }
            if (!_this._preloadObj) {
              _this._cjsStage.update();
            }
            if (_this._displayLayers.bgMask) {
              _this._displayLayers.bgMask.alpha = 1;
            }
            _this._displayLayers.toolbars = new createjs.Container;
            _this._cjsStage.addChild(_this._displayLayers.toolbars);
            _this._displayLayers.tooltip = new createjs.Container;
            _this._cjsStage.addChild(_this._displayLayers.tooltip);
            _this._toolTip = new window.DaTooltip(_this, {
              id: "tooltip",
              pointDirection: "right",
              width: 120
            });
            _this._displayLayers.tooltip.addChild(_this._toolTip._container);
            _this._displayLayers.walkthrough = new createjs.Container;
            _this._cjsStage.addChild(_this._displayLayers.walkthrough);
            _this._displayLayers.modals = new createjs.Container;
            _this._cjsStage.addChild(_this._displayLayers.modals);
            _this._displayLayers.fullLock = new createjs.Container;
            fullLockScreen = new createjs.Shape();
            fullLockScreen.graphics.beginFill('rgba(130,130,130,.7)');
            fullLockScreen.graphics.rect(0, 0, _this._canvRef.width, _this._canvRef.height);
            fullLockText = new createjs.Text(_this._managerRef.GetLang(_this, 'printBlock'), "20px Arial", "#FFFFFF");
            fullLockText.lineWidth = 250;
            fullLockText.x = 60;
            fullLockText.y = 40;
            _this._displayLayers.fullLock.addChild(fullLockScreen);
            _this._displayLayers.fullLock.addChild(fullLockText);
            _this.GetTttl();
            if (_this._toolbarManagerRef) {
              _this.DrawScreenUI(true);
              _this._cjsStage.setChildIndex(_this._preloadObj._container, _this._cjsStage.numChildren - 1);
              return _this._toolbarManagerRef.BuildToolbars(_this._DrawOptions.useToolbars, function() {
                _this.AppendButtons();
                if (_this._DrawOptions.useModals) {
                  return _this.BuildModals(function() {
                    if (_this._DrawOptions.useWalkthroughs) {
                      return _this.BuildWalkthroughs(finalInitSteps);
                    } else {
                      return finalInitSteps();
                    }
                  });
                } else {
                  if (_this._DrawOptions.useWalkthroughs) {
                    return _this.BuildWalkthroughs(finalInitSteps);
                  } else {
                    return finalInitSteps();
                  }
                }
              });
            } else {
              if (_this._DrawOptions.useWalkthroughs) {
                return _this.BuildWalkthroughs(finalInitSteps);
              } else {
                return finalInitSteps();
              }
            }
          };
          finalInitSteps = function() {
            if (_this._DrawOptions.Background || (_this._DrawOptions.SlideData && _this._DrawOptions.SlideData[_this._currentSlideIndex].Background)) {
              _this.getClonedImage(_this._displayLayers.bgMask.image, function(cImg) {
                return _this._eraseStrokeImage = cImg;
              }, {
                offsetPosition: {
                  x: _this._DrawOptions.cropRect[0],
                  y: _this._DrawOptions.cropRect[1]
                }
              });
            }
            if (_this._preloadObj) {
              _this._cjsStage.setChildIndex(_this._playScreenCont, _this._cjsStage.numChildren - 1);
              _this._cjsStage.setChildIndex(_this._preloadObj._container, _this._cjsStage.numChildren - 1);
              _this._cjsStage.update();
              _this._preloadObj.RequestEnd(function() {
                _this._managerRef.d2log(_this._domID + " is initialized");
                _this._initalized = true;
                _this.HandleInternalEvent("onReady");
                _this._managerRef.d2log(_this._domID + " Opening Slide 1");
                _this.HandleInternalEvent("onSlideOpen");
                _this._cjsStage.setChildIndex(_this._playScreenCont, _this._cjsStage.numChildren - 1);
                _this._cjsStage.setChildIndex(_this._preloadObj._container, _this._cjsStage.numChildren - 1);
                return _this._cjsStage.update();
              });
            } else {
              _this._managerRef.d2log(_this._domID + " is initialized");
              _this._initalized = true;
              _this.HandleInternalEvent("onReady");
              _this._managerRef.d2log(_this._domID + " Opening Slide 1");
              _this.HandleInternalEvent("onSlideOpen");
            }
          };
          if (appData.Config && appData.Config.Background) {
            _this.LoadBackground(appData.Config.Background, postBGload);
          } else if (_this._DrawOptions.SlideData) {
            _this.preloadSlideResources(function() {
              _this.ChangeBackground("Slide" + _this._currentSlideIndex + "_Background");
              return postBGload();
            });
          } else {
            postBGload();
          }
        };
      })(this));
      return this;
    };

    DrawingArea.prototype.preloadSlideResources = function(callback) {
      var loadedSldRes, sld, sldAssets, toltalSldRes;
      toltalSldRes = 0;
      loadedSldRes = 0;
      sldAssets = [];
      sld = 0;
      while (sld < this._DrawOptions.SlideData.length) {
        if (this._DrawOptions.SlideData[sld].SlideInstructionVO && this._DrawOptions.SlideData[sld].SlideInstructionVO !== '') {
          sldAssets.push({
            id: "Slide" + sld + "_vo",
            src: this._DrawOptions.SlideData[sld].SlideInstructionVO
          });
        }
        if (this._DrawOptions.SlideData[sld].Background && this._DrawOptions.SlideData[sld].Background !== '') {
          sldAssets.push({
            id: "Slide" + sld + "_Background",
            src: this._DrawOptions.SlideData[sld].Background
          });
        }
        sld++;
      }
      return this.PreloadDataResoucres(sldAssets, (function(_this) {
        return function() {
          if (callback) {
            return callback();
          }
        };
      })(this));
    };

    DrawingArea.prototype.LoadBackground = function(src, callback) {
      var bgImg, c, handleBGload;
      c = this.GetDaObjectById("bgMask");
      if (c) {
        this._cjsStage.removeChild(c);
        this._displayLayers.bgMask = void 0;
        this._cjsStage.update();
      }
      handleBGload = (function(_this) {
        return function(clnedImg) {
          if (clnedImg) {
            _this._displayLayers.bgMask = new createjs.Bitmap(clnedImg);
            _this._displayLayers.bgMask._id = "bgMask";
            _this._displayLayers.bgMask.x = _this._DrawOptions.cropRect[0];
            _this._displayLayers.bgMask.y = _this._DrawOptions.cropRect[1];
            if (_this._displayLayers.bgMask.stage !== _this._cjsStage) {
              _this._cjsStage.addChildAt(_this._displayLayers.bgMask, 1);
            }
            if (_this._DrawOptions.useCaching) {
              _this._displayLayers.bgMask.cache(0, 0, _this._canvRef.width, _this._canvRef.height);
            }
            if (callback) {
              return callback();
            }
          }
        };
      })(this);
      bgImg = new Image();
      bgImg.setAttribute("crossorigin", "anonymous");
      bgImg.setAttribute("style", "visibility: hidden");
      bgImg.src = this._managerRef.randomQuery(src);
      document.body.appendChild(bgImg);
      if (this._DrawOptions.cropRect) {
        return bgImg.onload = (function(_this) {
          return function(e) {
            document.body.removeChild(e.target);
            _this._displayLayers.bgMask = new createjs.Bitmap(_this.getClonedImage(e.target, handleBGload, {
              forceWidth: _this._DrawOptions.cropRect[2],
              forceHeight: _this._DrawOptions.cropRect[3],
              forceExtention: "png"
            }));
            return _this._displayLayers.bgMask._id = "bgMask";
          };
        })(this);
      }
    };

    DrawingArea.prototype.ChangeBackground = function(id, callback) {
      var c, handleBGload;
      handleBGload = (function(_this) {
        return function(clnedImg) {
          if (clnedImg) {
            _this._displayLayers.bgMask = new createjs.Bitmap(clnedImg);
            _this._displayLayers.bgMask._id = "bgMask";
            _this._displayLayers.bgMask.image.crossOrigin = "anonymous";
            _this._displayLayers.bgMask.x = _this._DrawOptions.cropRect[0];
            _this._displayLayers.bgMask.y = _this._DrawOptions.cropRect[1];
            if (_this._displayLayers.bgMask.stage !== _this._cjsStage) {
              _this._cjsStage.addChildAt(_this._displayLayers.bgMask, 1);
            }
            if (_this._DrawOptions.useCaching) {
              _this._displayLayers.bgMask.cache(0, 0, _this._canvRef.width, _this._canvRef.height);
            }
            if (callback) {
              return callback();
            }
          }
        };
      })(this);
      if (this._managerRef._loadedAssets.getItem(id)) {
        c = this.GetDaObjectById("bgMask");
        if (c) {
          this._cjsStage.removeChild(c);
          this._displayLayers.bgMask = void 0;
          this._cjsStage.update();
        }
        this._displayLayers.bgMask = new createjs.Bitmap(this._managerRef._loadedAssets.getItem(id).src);
        this._displayLayers.bgMask._id = "bgMask";
        this._displayLayers.bgMask.image.crossOrigin = "anonymous";
        this._displayLayers.bgMask.x = this._DrawOptions.cropRect[0];
        this._displayLayers.bgMask.y = this._DrawOptions.cropRect[1];
        if (this._DrawOptions.cropRect) {
          this._displayLayers.bgMask = new createjs.Bitmap(this.getClonedImage(this._displayLayers.bgMask.image, handleBGload, {
            forceWidth: this._DrawOptions.cropRect[2],
            forceHeight: this._DrawOptions.cropRect[3],
            forceExtention: "png"
          }));
          return this._displayLayers.bgMask._id = "bgMask";
        }
      }
    };

    DrawingArea.prototype.GetTttl = function() {
      var md, mdData, tb, tbData, tttlCount;
      this._preloadObj.SetPreloadStatus(10);
      tttlCount = 0;
      if (this._DrawOptions.useToolbars.constructor === Array) {
        tb = 0;
        while (tb < this._DrawOptions.useToolbars.length) {
          tbData = JSON.parse(this._managerRef._loadedAssets.getResult(this._DrawOptions.useToolbars[tb]));
          if (tbData.options.resources) {
            tttlCount += tbData.options.resources.length;
          }
          tb++;
        }
      }
      if (this._DrawOptions.useModals.constructor === Array) {
        md = 0;
        while (md < this._DrawOptions.useModals.length) {
          mdData = JSON.parse(this._managerRef._loadedAssets.getResult(this._DrawOptions.useModals[md]));
          if (mdData.options.resources) {
            tttlCount += mdData.options.resources.length;
          }
          md++;
        }
      }
      this._tttlMod = 90 / tttlCount;
      return tttlCount;
    };


    /**
    *
    * @method AppendButtons
    *
    * Build the buttons requested in the toolbar JSON data sheets
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.AppendButtons = function() {
      var button, buttonObj, i, len, ref;
      this._displayLayers.buttons = new createjs.Container;
      this._displayLayers.buttons._id = "buttons";
      ref = JSON.parse(this._managerRef._loadedAssets.getResult(this._DrawOptions.useToolbars)).buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        button = ref[i];
        buttonObj = new window.DaButton(this, button);
        this._buttons.push(buttonObj);
        this._displayLayers.buttons.addChild(buttonObj._container);
      }
      this._cjsStage.addChild(this._displayLayers.buttons);
      this._cjsStage.setChildIndex(this._displayLayers.modals, this._cjsStage.numChildren - 1);
      if (this._preloadObj && !this._initalized) {
        this._cjsStage.setChildIndex(this._preloadObj._container, this._cjsStage.numChildren - 1);
      }
      this._cjsStage.update();
    };


    /**
    *
    * @method DrawInteractiveMask
    *
    * Builds the CreateJS shape that can be interacted with to draw shapes. this is called on Init and from the resize handler.
    *
    * @param xPos:Number - the X position to begin drawing the shape
    * @param yPos:Number - the Y position to begin drawing the shape
    * @param width:Number  - the width of the shape
    * @param height:Number - the height of the shape
    * @return Void 0
    *
     */

    DrawingArea.prototype.DrawInteractiveMask = function(xPos, yPos, width, height) {
      if (!xPos) {
        xPos = 0;
      }
      if (!yPos) {
        yPos = 0;
      }
      if (!width) {
        width = this._canvRef.width;
      }
      if (!height) {
        height = this._canvRef.height;
      }
      this._displayLayers.interactiveArea.graphics.clear();
      this._displayLayers.interactiveArea.graphics.beginFill(this._DrawOptions.bg_color);
      this._displayLayers.interactiveArea.graphics.rect(0, 0, width, height);
      this._displayLayers.interactiveArea.x = xPos;
      this._displayLayers.interactiveArea.y = yPos;
    };

    DrawingArea.prototype.BuildWalkthroughs = function(callback) {
      var audioAssets, i, len, loadWTResources, loadedWTs, ref, results, st, toltalWTs, wTdata, wt;
      toltalWTs = 0;
      loadedWTs = 0;
      loadWTResources = (function(_this) {
        return function() {
          var i, len, loadedWtData, lwt, ref;
          loadedWTs++;
          if (loadedWTs === _this._DrawOptions.useWalkthroughs.length) {
            ref = _this._DrawOptions.useWalkthroughs;
            for (i = 0, len = ref.length; i < len; i++) {
              lwt = ref[i];
              loadedWtData = JSON.parse(_this._managerRef._loadedAssets.getResult(lwt));
              if (loadedWtData.Steps.constructor === String) {
                loadedWtData.Steps = _this._managerRef.ParseDataText(_this, loadedWtData.Steps);
              }
              _this._walkthroughs.push(new DaWalkthrough(_this, loadedWtData));
            }
            if (callback) {
              return callback();
            }
          }
        };
      })(this);
      ref = this._DrawOptions.useWalkthroughs;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        wt = ref[i];
        wTdata = JSON.parse(this._managerRef._loadedAssets.getResult(wt));
        if (wTdata.Steps.constructor === String) {
          wTdata.Steps = this._managerRef.ParseDataText(this, wTdata.Steps);
        }
        if (!wTdata.Steps || wTdata.Steps.length === 0) {
          if (this._DrawOptions.SlideData) {
            if (!this._DrawOptions.SlideData[this._currentSlideIndex].SlideInstruction || this._DrawOptions.SlideData[this._currentSlideIndex].SlideInstruction === "") {
              if (appData.Config.IntroWindowText === void 0 || appData.Config.IntroWindowText === "") {
                this.GetDaObjectById("Help").Disable();
                this.GetDaObjectById("Help").Move(-1000, 0);
              }
            }
          }
          loadedWTs++;
          if (loadedWTs === this._DrawOptions.useWalkthroughs.length) {
            if (callback) {
              results.push(callback());
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        } else {
          toltalWTs++;
          audioAssets = [];
          if (wTdata.Steps) {
            st = 0;
            while (st < wTdata.Steps.length) {
              if (wTdata.Steps[st].textVO) {
                audioAssets.push({
                  src: wTdata.Steps[st].textVO,
                  id: wTdata.ID + "_sVO" + st
                });
              }
              st++;
            }
          }
          results.push(this.PreloadDataResoucres(audioAssets, loadWTResources));
        }
      }
      return results;
    };


    /**
    *
    * @method BuildModals
    *
    * Builds the CreateJS shape that can be interacted with to draw shapes. this is called on Init and from the resize handler.
    *
    * @param callback:function - called once all the resources associated with the models are loaded.
    * @return Void 0
    *
     */

    DrawingArea.prototype.BuildModals = function(callback) {
      var loadModResources, loadedModals;
      loadedModals = 0;
      loadModResources = (function(_this) {
        return function(modalsData) {
          if (modalsData.options.resources) {
            return _this.PreloadDataResoucres(modalsData.options.resources, function() {
              var modal;
              loadedModals++;
              modal = new DaModal(_this, modalsData);
              modal._container.visible = false;
              _this._modals.push(modal);
              _this._displayLayers.modals.addChild(modal._container);
              if (loadedModals === _this._DrawOptions.useModals.length) {
                if (callback) {
                  return callback();
                }
              } else {
                return loadModResources(JSON.parse(_this._managerRef._loadedAssets.getResult(_this._DrawOptions.useModals[loadedModals])));
              }
            });
          } else {
            loadedModals++;
            if (loadedModals === _this._DrawOptions.useModals.length) {
              if (callback) {
                return callback();
              }
            } else {
              return loadModResources(JSON.parse(_this._managerRef._loadedAssets.getResult(_this._DrawOptions.useModals[loadedModals])));
            }
          }
        };
      })(this);
      loadModResources(JSON.parse(this._managerRef._loadedAssets.getResult(this._DrawOptions.useModals[loadedModals])));
    };


    /**
    *
    * @method PreloadDataResoucres
    *
    * When passed an array of resource elements this will sort our audio from binary and load them accordingly.
    *
    * @param resManifest:Array - Manifest of combined resources
    * @param callback:Function - called after all resources in manifest have been loaded.
    * @return Void 0
    *
     */

    DrawingArea.prototype.PreloadDataResoucres = function(resManifest, callback) {
      var audioRes, binaryRes, i, len, loadAudioArray, loadBinaryArray, res;
      binaryRes = [];
      audioRes = [];
      for (i = 0, len = resManifest.length; i < len; i++) {
        res = resManifest[i];
        res.src = this._managerRef.ParseDataText(this, res.src);
        if (res.src) {
          if (res.src.substring(res.src.length - 4).match(/^(.mp3|.wav|.mp4|.ogg)$/)) {
            audioRes.push(res);
          } else {
            binaryRes.push(res);
          }
        }
      }
      loadBinaryArray = (function(_this) {
        return function(lba_callback) {
          _this._preloadObj.SetPreloadStatus(_this._tttlMod, true);
          if (binaryRes.length !== 0) {
            _this._managerRef.PreloadResources(binaryRes, lba_callback);
          } else if (lba_callback) {
            lba_callback();
          }
        };
      })(this);
      loadAudioArray = (function(_this) {
        return function(laa_callback) {
          _this._preloadObj.SetPreloadStatus(_this._tttlMod, true);
          if (audioRes.length !== 0) {
            return _this._managerRef.PreloadAudio(audioRes, laa_callback);
          } else if (laa_callback) {
            return laa_callback();
          }
        };
      })(this);
      loadBinaryArray((function(_this) {
        return function() {
          return loadAudioArray(callback);
        };
      })(this));
    };


    /**
    *
    * @method GetModal
    *
    * Returns DaModal object with the id provided
    *
    * @param modID:String - id of modal to retrieve
    * @return DaModal | false - returns false if modal is not found
    *
     */

    DrawingArea.prototype.GetModal = function(modID) {
      var i, len, mod, ref;
      ref = this._modals;
      for (i = 0, len = ref.length; i < len; i++) {
        mod = ref[i];
        if (mod._id === modID) {
          return mod;
        }
      }
      return false;
    };


    /**
    *
    * @method GetWalkthrough
    *
    * Returns DaWalkthrough object with the id provided
    *
    * @param wtID:String - id of walkthrough to retrieve
    * @return Dawalkthrough | false - returns false if walkthrough is not found
    *
     */

    DrawingArea.prototype.GetWalkthrough = function(wtID) {
      var i, len, ref, wt;
      ref = this._walkthroughs;
      for (i = 0, len = ref.length; i < len; i++) {
        wt = ref[i];
        if (wt._id === wtID) {
          return wt;
        }
      }
      return false;
    };


    /**
    *
    * @method OpenModal
    *
    * OpenModal opens the modal with the id provided
    *
    * @param modID:String - id of modal to retrieve
    * @return Void 0
    *
     */

    DrawingArea.prototype.OpenModal = function(modID) {
      var mod;
      this.ModalLock();
      mod = this.GetModal(modID);
      if (mod) {
        mod.Open();
      }
    };


    /**
    *
    * @method CloseModal
    *
    * CloseModal closes the modal with the id provided
    *
    * @param modID:String - id of modal to retrieve
    * @return Void 0
    *
     */

    DrawingArea.prototype.CloseModal = function(modID, callback) {
      var mod;
      this.ModalUnlock();
      mod = this.GetModal(modID);
      if (mod) {
        mod.Close(callback);
      }
      if (this._walkthroughRequested !== false) {
        this._walkthroughs[this._walkthroughRequested].Start();
        this._walkthroughRequested = false;
      }
    };


    /**
    *
    * @method ModalLock
    *
    * ModalLock enables the lock on all buttons and toggles not associated with a modal,
    * thus preventing the user from clicking things behind the modal
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.ModalLock = function() {
      var b, i, len, ref;
      this._modalLock = true;
      this._enabled = false;
      this._toolbarManagerRef.DisableAll();
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        b.Disable();
      }
    };


    /**
    *
    * @method ModalUnlock
    *
    * ModalLock Disables the lock on all buttons and toggles not associated with a modal.
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.ModalUnlock = function() {
      var b, i, len, ref;
      this._modalLock = false;
      this._enabled = true;
      this._toolbarManagerRef.EnableAll();
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        b.Enable();
      }
    };


    /**
    *
    * @method DrawScreenUI
    *
    * This invisible screen appears when a toolbar flyover is open. it will close the fly over if the user clicks outside of the toolbar.
    * this is called from the Init function and again on window resize events
    *
    * @param intial:Boolean - true if this is being called from the Init Function
    * @return Void 0
    *
     */

    DrawingArea.prototype.DrawScreenUI = function(intial) {
      if (intial || !this._displayLayers.screenUI) {
        this._displayLayers.screenUI = new createjs.Shape();
      } else {
        this._displayLayers.screenUI.graphics.clear();
      }
      this._displayLayers.screenUI.graphics.beginFill('rgba(255,255,255,.01)');
      this._displayLayers.screenUI.graphics.rect(0, 0, this._canvRef.width, this._canvRef.height);
      if (intial) {
        this._displayLayers.screenUI.addEventListener('click', this.DeactivateScreenUI);
      }
    };


    /**
    *
    * @method ActivateScreenUI
    *
    * This will activate the invisible screen appears when a toolbar flyover is open., ensuring it is at the correct Z position.
    * this also disables everything under it.
    *
    * @param  Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.ActivateScreenUI = function() {
      if (this._displayLayers.overlay) {
        this._cjsStage.addChildAt(this._displayLayers.screenUI, this._cjsStage.getChildIndex(this._displayLayers.overlay) + 1);
      } else {
        this._cjsStage.addChildAt(this._displayLayers.screenUI, this._cjsStage.getChildIndex(this._displayLayers.drawContainer) + 1);
      }
      this._enabled = false;
    };


    /**
    *
    * @method DeactivateScreenUI
    *
    * This will deactivate the invisible screen appears when a toolbar flyover is open. this will re enable everything in the drawing area.
    *
    * @param  Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.DeactivateScreenUI = function(bypassLock) {
      if (!this._modalLock) {
        this._cjsStage.removeChild(this._displayLayers.screenUI);
        this._enabled = true;
        this._toolbarManagerRef.CloseRequest();
      } else if (bypassLock) {
        this._cjsStage.removeChild(this._displayLayers.screenUI);
        this._toolbarManagerRef.CloseRequest();
      }
    };


    /**
    *
    * @method ParseOptions
    *
    * This take the provided options from the Drawing area being set and use them to define the DrawOptions proprieties accordingly
    *
    * @param  ops:Array - a list of various options and values
    * @param  callback:Functions - as some options may require a load the callback is a safe method of ensuring a post process can occur.
    * @return Void 0 - This may be the callback function call in situations where loading isnt required.
    *
     */

    DrawingArea.prototype.ParseOptions = function(ops, callback) {
      if (!ops) {
        ops = {};
      }
      this._daModeSet = "basic";
      this._events = ops.events;
      this._displayLayers = {};
      this._langSet = "EN";
      if (ops.languageCode) {
        this._langSet = ops.languageCode;
      }
      if (ops.adaptive) {
        this._AdaptiveOptions.adaptive = ops.adaptive;
      }
      if (!ops.mode) {
        ops.mode = "standard";
        this._DrawOptions.useCaching = false;
      }
      if (ops.mode === "basic") {
        this._daModeSet = "basic";
        this._DrawOptions.useCaching = false;
        if (ops.size) {
          this._DrawOptions.size = ops.size;
        }
        if (this._DrawOptions.size.constructor === String) {
          this._DrawOptions.size = parseFloat(this._DrawOptions.size);
        }
        if (ops.color) {
          this._DrawOptions.color = ops.color;
        }
        if (ops.backgroundColor) {
          this._DrawOptions.bg_color = ops.backgroundColor;
        }
        if (ops.overlayImage) {
          this._displayLayers.overlay = ops.overlayImage;
        }
        return callback();
      } else if (ops.mode === "reveal") {
        this._daModeSet = "reveal";
        this._DrawOptions.useCaching = true;
        if (ops.size) {
          this._DrawOptions.size = ops.size;
        }
        if (this._DrawOptions.size.constructor === String) {
          this._DrawOptions.size = parseFloat(this._DrawOptions.size);
        }
        if (ops.backgroundImage && ops.backgroundImage !== "") {
          this._displayLayers.bgMask = ops.backgroundImage;
        }
        if (ops.overlayImage) {
          this._displayLayers.background = ops.overlayImage;
        }
        return callback();
      } else if (ops.mode === "control") {
        this._daModeSet = "control";
        this._DrawOptions.useCaching = false;
        if (ops.size) {
          this._DrawOptions.size = ops.size;
        }
        if (this._DrawOptions.size.constructor === String) {
          this._DrawOptions.size = parseFloat(this._DrawOptions.size);
        }
        if (ops.color) {
          this._DrawOptions.color = ops.color;
        }
        if (ops.backgroundColor) {
          this._DrawOptions.bg_color = ops.backgroundColor;
        }
        if (ops.overlayImage) {
          this._displayLayers.overlay = ops.overlayImage;
        }
        return callback();
      } else if (ops.mode === "display") {
        this._daModeSet = "display";
        this._DrawOptions.useCaching = false;
        if (ops.backgroundColor) {
          this._DrawOptions.bg_color = ops.backgroundColor;
        }
        if (ops.overlayImage && backgroundImage !== "") {
          this._displayLayers.overlay = ops.overlayImage;
        }
        this._DrawOptions.displaySourceRef = this._managerRef.GetDrawingArea(ops.displaySource);
        return callback();
      } else if (ops.mode === "standard") {
        this._daModeSet = "standard";
        this._DrawOptions.useCaching = false;
        this._toolbarManagerRef = new DaToolbarManager(this);
        if (ops.SlideData && ops.SlideData.length !== 0) {
          this._usingSlidesData = ops.SlideData;
          if (ops.SlideData[this._currentSlideIndex].Background && ops.SlideData[this._currentSlideIndex].Background !== "") {
            this._displayLayers.bgMask = ops.SlideData[this._currentSlideIndex].Background;
          } else {
            this._displayLayers.bgMask = new createjs.Bitmap(this._managerRef._loadedAssets.getResult('blankCanvas'));
          }
          this._DrawOptions.SlideData = ops.SlideData;
        } else if (ops.backgroundImage && ops.backgroundImage !== "") {
          this._displayLayers.bgMask = ops.backgroundImage;
        }
        if (ops.backgroundColor) {
          this._DrawOptions.bg_color = ops.backgroundColor;
        }
        if (ops.overlayImage) {
          this._displayLayers.overlay = ops.overlayImage;
        }
        if (ops.cropRect) {
          this._DrawOptions.cropRect = ops.cropRect;
        }
        this._DrawOptions.useToolbars = ops.useToolbars;
        this._DrawOptions.useWalkthroughs = ops.useWalkthroughs;
        if (ops.useModals) {
          this._DrawOptions.useModals = ops.useModals;
        }
        return callback();
      }
    };


    /**
    *
    * @method distanceBetween
    *
    * based on //www.tricedesigns.com/2012/01/04/sketching-with-html5-canvas-and-brush-images/
    *
    * This function will calculate the distance between the points provided. this is used in drawing to achieve a tapering effect.
    *
    * @param  point1:object - contains 'x' and 'y' keys for number values
    * @param  point2:object - contains 'x' and 'y' keys for number values
    * @return Number - the calculated distance.
    *
     */

    DrawingArea.prototype.distanceBetween = function(point1, point2) {
      return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
    };

    DrawingArea.prototype.getClonedImage = function(image, callback, options) {
      var cloneImage, handlCloneCompLoaded, imgClone, tempID;
      tempID = "tempImg" + new Date().getTime();
      imgClone = null;
      cloneImage = (function(_this) {
        return function() {
          image.onload = void 0;
          imgClone = image.cloneNode();
          imgClone.id = tempID;
          _this._canvRef.parentElement.appendChild(imgClone);
          if (imgClone.complete) {
            handlCloneCompLoaded();
          } else {
            imgClone.onload = handlCloneCompLoaded;
          }
          return imgClone;
        };
      })(this);
      handlCloneCompLoaded = function() {
        var ctx, imgExtn, tempCanvas, tempImgDom;
        tempCanvas = document.createElement('CANVAS');
        ctx = tempCanvas.getContext('2d');
        if (options.forceHeight) {
          imgClone.height = options.forceHeight;
          tempCanvas.height = options.forceHeight;
        } else {
          tempCanvas.height = image.naturalHeight;
        }
        if (options.forceWidth) {
          imgClone.width = options.forceWidth;
          tempCanvas.width = options.forceWidth;
        } else {
          tempCanvas.width = image.naturalWidth;
        }
        if (options.forceWidth && options.forceHeight) {
          ctx.beginPath();
          ctx.rect(0, 0, options.forceWidth, options.forceHeight);
          ctx.fillStyle = "#FFFFFF";
          ctx.fill();
        }
        if (options.offsetPosition) {
          tempCanvas.width += options.offsetPosition.x;
          tempCanvas.height += options.offsetPosition.y;
          ctx.drawImage(imgClone, options.offsetPosition.x, options.offsetPosition.y);
        } else {
          ctx.drawImage(imgClone, 0, 0, imgClone.width, imgClone.height);
        }
        if (options.forceExtention) {
          imgExtn = options.forceExtention;
        } else {
          imgExtn = imgClone.src.substr(imgClone.src.lastIndexOf('.') + 1).toUpperCase();
          if (imgExtn === "JPG") {
            imgExtn = "JPEG";
          }
        }
        imgClone.src = tempCanvas.toDataURL("image/" + imgExtn);
        if (imgClone.src === "data:,") {
          this._managerRef.d2log("failed to clone image data");
          this._managerRef.d2log(image);
          return;
        }
        imgClone.onload = null;
        tempImgDom = document.getElementById(tempID);
        if (tempImgDom) {
          tempImgDom.parentElement.removeChild(tempImgDom);
        }
        if (callback) {
          return callback(imgClone);
        }
      };
      if (image) {
        if (image.complete === false) {
          image.onload = cloneImage;
          return image;
        } else {
          return cloneImage();
        }
      }
    };


    /**
    *
    * @method HandleMouseMove
    *
    * One of the most important functions of the Drawing area, this handles the drawing. when the mouse is being pressed and moved (or tap and drag with mobile)
    * using the EaselJS Graphics API this function calculates a series of lines based on the movement of the user, drawing the requested shape.
    * in some cases this shape is cached an reached on each event call allowing effects to be viewed in real time.
    *
    * @param  evt:Event - a Mouse move event providing the current coordinates of the mouse.
    * @return void 0
    *
     */

    DrawingArea.prototype.HandleMouseMove = function(evt) {
      var color, diChild, disFact, dist, gr, opa;
      if (this._isDrawing && this._daModeSet !== 'display' && this._enabled && this._loadLock === 0 && evt.stageX >= evt.target.x && evt.stageY >= evt.target.y && !this._DrawOptions.stampMode) {
        if (!this._DrawOptions.cropRect || this._DrawOptions.cropRect && (evt.stageX > this._DrawOptions.cropRect[0] && evt.stageX < this._DrawOptions.cropRect[0] + this._DrawOptions.cropRect[2] && evt.stageY > this._DrawOptions.cropRect[1] && evt.stageY < this._DrawOptions.cropRect[1] + this._DrawOptions.cropRect[3])) {
          if (this._coordinates.oldX) {
            diChild = this._displayLayers.drawContainer.children[this._displayLayers.drawContainer.numChildren - 1];
            gr = diChild.graphics;
            if (this._DrawOptions.eraseMode) {
              if (this._eraseStrokeImage) {
                gr.beginBitmapStroke(this._eraseStrokeImage);
              } else {
                gr.beginStroke(this._DrawOptions.bg_color);
              }
            } else {
              gr.beginStroke(this._DrawOptions.color);
            }
            if (this._DrawOptions.penType === "square" || this._DrawOptions.penType === "round") {
              gr.setStrokeStyle(this._DrawOptions.size, this._DrawOptions.penType);
            } else if (this._DrawOptions.penType === "paint") {
              gr.setStrokeStyle(this._DrawOptions.size, "round", "round");
              dist = this.distanceBetween({
                x: this._coordinates.oldX,
                y: this._coordinates.oldY
              }, {
                x: evt.stageX,
                y: evt.stageY
              });
            }
            if (this._DrawOptions.cropRect) {
              if (this._coordinates.oldX < this._DrawOptions.cropRect[0]) {
                this._coordinates.oldX = this._DrawOptions.cropRect[0];
              }
              if (this._coordinates.oldX > this._DrawOptions.cropRect[0] + this._DrawOptions.cropRect[2]) {
                this._coordinates.oldX = this._DrawOptions.cropRect[0] + this._DrawOptions.cropRect[2];
              }
              if (this._coordinates.oldY < this._DrawOptions.cropRect[1]) {
                this._coordinates.oldY = this._DrawOptions.cropRect[1];
              }
              if (this._coordinates.oldY > this._DrawOptions.cropRect[1] + this._DrawOptions.cropRect[3]) {
                this._coordinates.oldY = this._DrawOptions.cropRect[1] + this._DrawOptions.cropRect[3];
              }
            }
            if (this._DrawOptions.penType === "paint") {
              disFact = this._DrawOptions.size;
              if ((disFact * (disFact / dist)) < this._DrawOptions.size) {
                disFact = disFact * (disFact / dist);
              }
              if (disFact < this._DrawOptions.size * .7) {
                disFact = this._DrawOptions.size * .7;
              }
              if (!this._oldDistFact) {
                this._oldDistFact = disFact;
              }
              opa = this._DrawOptions.penOpacity / 100;
              if (this._DrawOptions.color[0] === '#') {
                color = this._managerRef.HexToRGBA(this._DrawOptions.color, opa);
              }
              gr.beginFill(color);
              gr.endStroke();
              gr.lineTo(this._coordinates.oldX + this._oldDistFact, this._coordinates.oldY + this._oldDistFact);
              gr.lineTo(evt.stageX + disFact, evt.stageY + disFact);
              gr.lineTo(evt.stageX - disFact, evt.stageY - disFact);
              gr.lineTo(this._coordinates.oldX - this._oldDistFact, this._coordinates.oldY - this._oldDistFact);
              this._oldDistFact = disFact;
            } else {
              gr.moveTo(this._coordinates.oldX, this._coordinates.oldY);
              gr.lineTo(evt.stageX, evt.stageY);
            }
          }
          this._coordinates.oldX = evt.stageX;
          this._coordinates.oldY = evt.stageY;
          if (diChild.cacheID === 0) {
            if (this._DrawOptions.cropRect) {
              if (this._DrawOptions.penType === "paint") {
                diChild.cacheQuality = .3;
              } else {
                diChild.cacheQuality = 1;
              }
              diChild.cache(this._DrawOptions.cropRect[0], this._DrawOptions.cropRect[1], this._DrawOptions.cropRect[2], this._DrawOptions.cropRect[3], diChild.cacheQuality);
            } else {
              diChild.cache(0, 0, this._canvRef.width, this._canvRef.height);
            }
          }
          this.HandleInternalEvent("whileDraw");
        }
      }
    };


    /**
    *
    * @method HandleMouseDown
    *
    * This occurs when the mouse (or finger) is pressed down in the canvas.
    * Since this must occur prior to the HandleMouseMove function this function prepares the stage for it.
    *
    * @param  evt:Event - a Mouse down event providing the current coordinates of the mouse.
    * @return Void 0
    *
     */

    DrawingArea.prototype.HandleMouseDown = function(evt) {
      var diItem;
      if (this._enabled && this._loadLock === 0) {
        this._mdFlag = true;
        this._oldDistFact = void 0;
        this._coordinates.oldX = evt.stageX;
        this._coordinates.oldY = evt.stageY;
        this._isDrawing = true;
        if (this._DrawOptions.stampMode && this._stampLock === 0) {
          diItem = this.BuildStamp();
          this._stampLock = 3;
          diItem.x = evt.stageX;
          diItem.y = evt.stageY;
        } else {
          diItem = new createjs.Shape();
        }
        diItem.filters = [];
        if (this._DrawOptions.fade && !this._DrawOptions.eraseMode) {
          diItem.filters.push(new createjs.BlurFilter(this._DrawOptions.fade, this._DrawOptions.fade, .2));
        }
        this._displayLayers.drawContainer.addChild(diItem);
        this.HandleInternalEvent("drawStart");
      }
    };


    /**
    *
    * @method HandleMouseUp
    *
    * This occurs when the mouse (or finger) is removed from canvas.
    * Since this must occur after to the HandleMouseMove function this function calls the Bake function and ends the caching.
    * this also has a mis click detection. If a click was made, and nothing was drawn, it wont count.
    *
    * @param  evt:Event - a Mouse up event providing the current coordinates of the mouse.
    * @return Void 0
    *
     */

    DrawingArea.prototype.HandleMouseUp = function(evt) {
      var gr, lastChild;
      if (this._enabled && this._mdFlag) {
        this._mdFlag = false;
        this._loadLock = 3;
        this.Update();
        lastChild = this._displayLayers.drawContainer.children[this._displayLayers.drawContainer.numChildren - 1];
        this._isDrawing = false;
        if (lastChild) {
          gr = lastChild.graphics;
          if (gr && gr._instructions && gr._instructions.length === 0 && !this._DrawOptions.stampMode) {
            this._displayLayers.drawContainer.removeChildAt(this._displayLayers.drawContainer.numChildren - 1);
          } else {
            this._undoMemory = [];
            this._clearFlag = false;
            if (lastChild.cacheCanvas) {
              lastChild.updateCache();
            }
            this.BakeDrawLayers();
            lastChild.visible = false;
            lastChild.uncache();
          }
        }
        this.HandleInternalEvent("drawEnd");
      }
    };


    /**
    *
    * @method BakeDrawLayers
    *
    * called from HandleMouseUp, this will take all visible drawn layers and create a merged copy of them. the original layers are then hidden.
    * doing this prevent the caching process from having to redraw every individual drawing layer on every tick (that'd be super laggy)
    *
    * @param reset:Boolean - when this is true all layers are made visible when reaching, this is slower but necessary in some cases such as "undo"
    * @param callback:Function - since this function technically creates a new image, some browsers need a tick or two before attempting to use the image in anyway
    * @return Void 0
    *
     */

    DrawingArea.prototype.BakeDrawLayers = function(reset, callback) {
      var bakeLayer, bakedBitmap, cl, i, layersLoaded, layersToLoad, len, newcl, onLayerLoad, onLd1, onLd2, ref;
      this._displayLayers.drawContainer.cache(0, 0, this._canvRef.width, this._canvRef.height);
      this._loadLock = 3;
      bakeLayer = new createjs.Container();
      layersToLoad = 0;
      layersLoaded = 0;
      onLayerLoad = (function(_this) {
        return function(e) {
          e.target.removeEventListener("load", onLayerLoad, false);
          layersLoaded++;
          if (layersLoaded === layersToLoad) {
            return onLd1();
          }
        };
      })(this);
      onLd1 = (function(_this) {
        return function() {
          bakeLayer.cache(0, 0, _this._canvRef.width, _this._canvRef.height);
          return _this._displayLayers.histLayer.image.src = bakeLayer.getCacheDataURL().valueOf();
        };
      })(this);
      onLd2 = (function(_this) {
        return function(e) {
          _this._displayLayers.histLayer.image.removeEventListener("load", onLd2);
          _this._displayLayers.drawContainer.uncache();
          bakeLayer.uncache();
          _this._loadLock = 0;
          if (callback) {
            return callback();
          }
        };
      })(this);
      if (!reset) {
        bakeLayer.addChild(this._displayLayers.histLayer.clone());
        bakedBitmap = new createjs.Bitmap(this._displayLayers.drawContainer.cacheCanvas);
        bakeLayer.addChild(bakedBitmap);
        onLd1();
      } else {
        ref = this._displayLayers.drawContainer.children;
        for (i = 0, len = ref.length; i < len; i++) {
          cl = ref[i];
          newcl = cl.clone();
          newcl.cacheQuality = cl.cacheQuality;
          if (newcl.cacheQuality && newcl.cacheQuality !== 1) {
            newcl.cacheCanvas = cl.cacheCanvas;
            newcl.cache(0, 0, this._canvRef.width, this._canvRef.height, cl.cacheQuality);
          }
          bakeLayer.addChild(newcl);
          if (newcl.image && !newcl.image.complete) {
            layersToLoad++;
            newcl.image.addEventListener("load", onLayerLoad, false);
          }
        }
        if (layersToLoad === 0) {
          onLd1();
        }
      }
      if (!this._displayLayers.histLayer.image.complete) {
        this._displayLayers.histLayer.image.removeEventListener("load", onLd2);
        this._displayLayers.histLayer.image.addEventListener("load", onLd2, false);
      } else {
        onLd2();
      }
    };


    /**
    *
    * @method Update
    *
    * called every tick (depending on the FPS setting) this enforce temporary locks and call the stage update/cache updates.
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.Update = function() {
      var diChild, maskFilter;
      if (this._initalized) {
        if (this._daModeSet === "reveal") {
          maskFilter = new createjs.AlphaMaskFilter(this._displayLayers.drawContainer.cacheCanvas);
          this._displayLayers.bgMask.filters = [maskFilter];
          this._displayLayers.bgMask.updateCache();
        }
        if (this._loadLock === 0) {
          if (this._isDrawing) {
            diChild = this._displayLayers.drawContainer.children[this._displayLayers.drawContainer.numChildren - 1];
            if (diChild.cacheID !== 0) {
              diChild.updateCache();
            }
          }
          if (this._stampLock !== 0) {
            this._stampLock--;
          }
        } else {
          this._loadLock--;
        }
      }
      if (this._loadLock === 0) {
        return this._cjsStage.update();
      }
    };


    /**
    *
    * @method HandleResizeEvent
    *
    * called whenever the window changes size, this will adjust the Drawing area accordingly if the Drawing area is set to dynamic
    *
    * @param evt:event - windows resize event.
    * @return Void 0
    *
     */

    DrawingArea.prototype.HandleResizeEvent = function(evt) {
      var ratio, useHeight;
      if (this._AdaptiveOptions.adaptive === true || this._AdaptiveOptions.adaptive === "true") {
        ratio = this._initCanvasDimentions.width / this._canvRef.offsetWidth;
        useHeight = this._initCanvasDimentions.height * ratio;
        if (useHeight > this._initCanvasDimentions.height) {
          useHeight = this._initCanvasDimentions.height;
        }
        this._canvRef.setAttribute("height", useHeight);
        this.DrawInteractiveMask();
        this.DrawScreenUI();
        if (this._toolbarManagerRef) {
          this._toolbarManagerRef.HandleResizeEvent(evt);
        }
      }
    };


    /**
    *
    * @method GetDaObjectById
    *
    * Retrieves an object such as a DaButton, DoToolbar, or DaToggle
    *
    * @param objID:String the id value of the object to retrieve
    * @return Object | false - false if not found
    *
     */

    DrawingArea.prototype.GetDaObjectById = function(objID) {
      var but, fo, i, j, k, l, len, len1, len2, len3, len4, m, ref, ref1, ref2, ref3, ref4, res, searchObj, subTog, tb, tbt;
      searchObj = (function(_this) {
        return function(id, prnt) {
          var ch, i, len, ref, subSrch;
          ref = prnt.children;
          for (i = 0, len = ref.length; i < len; i++) {
            ch = ref[i];
            if (ch._id === id) {
              return ch;
            } else if (ch.children && ch.children.length !== 0) {
              subSrch = searchObj(id, ch);
              if (subSrch !== false) {
                return subSrch;
              }
            }
          }
          return false;
        };
      })(this);
      res = searchObj(objID, this._cjsStage);
      if (!res) {
        ref = this._toolbarManagerRef._toolbars;
        for (i = 0, len = ref.length; i < len; i++) {
          tb = ref[i];
          if (tb._id === objID) {
            res = tb;
          } else {
            ref1 = tb._toggles;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              tbt = ref1[j];
              if (tbt._id === objID) {
                res = tbt;
              }
            }
            if (!res) {
              ref2 = tb._flyouts;
              for (k = 0, len2 = ref2.length; k < len2; k++) {
                fo = ref2[k];
                if (fo._id === objID) {
                  res = fo;
                } else {
                  ref3 = fo.subToggles;
                  for (l = 0, len3 = ref3.length; l < len3; l++) {
                    subTog = ref3[l];
                    if (subTog._id === objID) {
                      res = subTog;
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (!res) {
        ref4 = this._buttons;
        for (m = 0, len4 = ref4.length; m < len4; m++) {
          but = ref4[m];
          if (but._id === objID) {
            res = but;
          }
        }
      }
      return res;
    };


    /**
    *
    * @method BuildStamp
    *
    * on Mouse down, if in stamp mode, this function is called to build the stamp shape
    *
    * @param Void 0
    * @return createJS.Shape
    *
     */

    DrawingArea.prototype.BuildStamp = function() {
      var shapeObj;
      switch (this._DrawOptions.stampSelection) {
        case "circle":
          shapeObj = new createjs.Shape();
          shapeObj.graphics.setStrokeStyle(4, "round");
          shapeObj.graphics.beginStroke(this._DrawOptions.color);
          shapeObj.graphics.drawCircle(0, 0, 20);
          return shapeObj;
        case "triangle":
          shapeObj = new createjs.Shape();
          shapeObj.regX = 20;
          shapeObj.regY = 20;
          shapeObj.graphics.setStrokeStyle(4, "square", "round", 5);
          shapeObj.graphics.beginStroke(this._DrawOptions.color);
          shapeObj.graphics.moveTo(20, 0);
          shapeObj.graphics.lineTo(40, 40);
          shapeObj.graphics.lineTo(0, 40);
          shapeObj.graphics.lineTo(20, 0);
          return shapeObj;
        case "square":
          shapeObj = new createjs.Shape();
          shapeObj.graphics.setStrokeStyle(4, "round");
          shapeObj.graphics.beginStroke(this._DrawOptions.color);
          shapeObj.graphics.rect(0, 0, 40, 40);
          shapeObj.regX = 20;
          shapeObj.regY = 20;
          return shapeObj;
        case "star":
          shapeObj = new createjs.Shape();
          shapeObj.graphics.setStrokeStyle(4, "square", "round", 5);
          shapeObj.graphics.beginStroke(this._DrawOptions.color);
          shapeObj.graphics.drawPolyStar(0, 0, 20, 5, .6, -90);
          return shapeObj;
      }
    };


    /**
    *
    * @method Clear
    *
    * Builds a big rectangular shape the same color as the selected background
    * This gives the illusion of clearing the stage but retaining all of the stage data for the Undo function
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.Clear = function() {
      var clearMsk, clearSrq;
      if (!this._clearFlag) {
        if (this._displayLayers.bgMask) {
          clearMsk = this._displayLayers.bgMask.clone();
          clearMsk.x = this._DrawOptions.cropRect[0];
          clearMsk.y = this._DrawOptions.cropRect[1];
          this._displayLayers.drawContainer.addChild(clearMsk);
        } else {
          clearSrq = new createjs.Shape();
          clearSrq.graphics.beginFill(this._DrawOptions.bg_color);
          clearSrq.graphics.rect(0, 0, this._canvRef.width, this._canvRef.height);
          this._displayLayers.drawContainer.addChild(clearSrq);
        }
        this.BakeDrawLayers();
        if (clearMsk) {
          clearMsk.visible = false;
        }
        if (clearSrq) {
          clearSrq.visible = false;
        }
        this._clearFlag = true;
      }
    };


    /**
    *
    * @method PrepCaptureStage
    *
    * Called in the event of a Capture or Print event. This will alter the Drawing Area layout to the required appearance
    * by creating a temporary stage (this stage will not be visible on the dom) and populating it with the graphics in the visible drawing area.
    *
    * @param Void 0
    * @return createJS.stage - the stage of a temporary canvas.
    *
     */

    DrawingArea.prototype.PrepCaptureStage = function(callback) {
      return this.HandleInternalEvent("onSaveReq", (function(_this) {
        return function() {
          var cnvrtCnvs, stage, stgBg;
          cnvrtCnvs = document.createElement('canvas');
          cnvrtCnvs.width = _this._canvRef.width;
          cnvrtCnvs.height = _this._canvRef.height;
          cnvrtCnvs.hidden = true;
          cnvrtCnvs.id = 'DaSnapCanvas';
          document.body.appendChild(cnvrtCnvs);
          stage = new createjs.Stage('DaSnapCanvas');
          stgBg = new createjs.Shape();
          stgBg.graphics.beginFill(_this._DrawOptions.bg_color);
          stgBg.graphics.rect(0, 0, cnvrtCnvs.width, cnvrtCnvs.height);
          stage.addChild(stgBg);
          if (_this._displayLayers.background) {
            stage.addChild(_this._displayLayers.background.clone());
          }
          if (_this._displayLayers.bgMask) {
            _this._displayLayers.bgMask._id = "bgMask";
            stage.addChild(_this._displayLayers.bgMask.clone());
          }
          if (_this._displayLayers.histLayer) {
            stage.addChild(_this._displayLayers.histLayer.clone());
          }
          if (_this._displayLayers.overlay) {
            stage.addChild(_this._displayLayers.overlay.clone());
          }
          stage.update();
          _this.DeactivateScreenUI();
          _this._cjsStage.addChild(_this._displayLayers.fullLock);
          _this._enabled = false;
          _this._toolbarManagerRef.DisableAll();
          _this._cjsStage.update();
          if (callback) {
            return callback(stage);
          }
        };
      })(this));
    };


    /**
    *
    * @method DestroyCaptureStage
    *
    * After a capture or print event has completed this function destroys the temporary stage and canvas.
    *
    * @param Void 0
    * @return createJS.stage - the stage of a temporary canvas.
    *
     */

    DrawingArea.prototype.DestroyCaptureStage = function(stage) {
      stage.removeAllChildren();
      document.body.removeChild(stage.canvas);
      this._cjsStage.removeChild(this._displayLayers.fullLock);
      this._enabled = true;
      this._toolbarManagerRef.EnableAll();
      return this.HandleInternalEvent("onSaveEnd");
    };


    /**
    *
    * @method GetImageDataURl
    *
    * This is the older method of Capturing the canvas image, this will use the PrepCaptureStage function and produce a Base64 data link to the image created
    *
    * @param Void 0
    * @return String - a Base64 src for the image data captured
    *
     */

    DrawingArea.prototype.GetImageDataURl = function(callback) {
      return this.PrepCaptureStage((function(_this) {
        return function(stage) {
          var ImageURLData;
          ImageURLData = stage.canvas.toDataURL('image/png');
          _this.DestroyCaptureStage(stage);
          if (callback) {
            return callack(ImageURLData);
          }
        };
      })(this));
    };


    /**
    *
    * @method DownloadImage
    *
    * The newer capture method. this uses the PrepCaptureStage and the external canvas to blob library as well as the File Saver library to directly download the capture image.
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.DownloadImage = function(callback) {
      return this.PrepCaptureStage((function(_this) {
        return function(stage) {
          stage.canvas.toBlob(function(blob) {
            return saveAs(blob, "Sketchbook Capture - " + (new Date().getTime()) + ".jpeg");
          }, "image/jpeg", 1);
          _this.DestroyCaptureStage(stage);
          if (callback) {
            return callback();
          }
        };
      })(this));
    };


    /**
    *
    * @method PrintImage
    *
    * Printing is similar to capture. however instead of saving the data, print will place the image in a new window then print the window.
    * Using this method places a special lock. This is necessary as the original window (or tab) will not function while a print dialog is open.
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.PrintImage = function() {
      this.PrepCaptureStage((function(_this) {
        return function(stage) {
          var pdf, pg;
          pdf = new jsPDF('l');
          pg = 0;
          pdf.addImage(stage.canvas.toDataURL("image/png"), 'PNG', 50, 20);
          pdf.save("Sketchbook_Capture-" + (new Date().getTime()) + ".pdf");
          return _this.DestroyCaptureStage(stage);
        };
      })(this));
    };


    /**
    *
    * @method RequestUndo
    *
    * As the name implies this will undo the last user interaction to the Drawing area, examples include: drawing a line, stamping, or clearing the stage.
    * Doing this requires a reset with the BakeDrawLayers function 
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.RequestUndo = function() {
      var ch, i, lastChild, len, ref;
      if (this._displayLayers.drawContainer.numChildren !== 0 && this._loadLock === 0) {
        this.HandleInternalEvent("onUndo");
        this.HandleInternalEvent("onUndoStart");
        lastChild = this._displayLayers.drawContainer.children[this._displayLayers.drawContainer.numChildren - 1];
        this._undoMemory.push([lastChild.clone()]);
        this._displayLayers.drawContainer.removeChildAt(this._displayLayers.drawContainer.numChildren - 1);
        ref = this._displayLayers.drawContainer.children;
        for (i = 0, len = ref.length; i < len; i++) {
          ch = ref[i];
          ch.visible = true;
        }
        return this.BakeDrawLayers(true, (function(_this) {
          return function() {
            var j, len1, ref1;
            ref1 = _this._displayLayers.drawContainer.children;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              ch = ref1[j];
              ch.visible = false;
              ch.uncache();
            }
            _this._clearFlag = false;
            return _this.HandleInternalEvent("onUndoEnd");
          };
        })(this));
      }
    };


    /**
    *
    * @method RequestRedo
    *
    * This being the opposite of Undo. Redo is only available after an Undo has been preformed, 
    * the redo history is reset if the user preforms any action after (other than undo) after the undo history has been formed.
    *
    * @param Void 0
    * @return Void 0
    *
     */

    DrawingArea.prototype.RequestRedo = function() {
      var i, len, memTarg, mt;
      if (this._undoMemory.length !== 0) {
        this.HandleInternalEvent("onRedo");
        memTarg = this._undoMemory[this._undoMemory.length - 1];
        for (i = 0, len = memTarg.length; i < len; i++) {
          mt = memTarg[i];
          this._displayLayers.drawContainer.addChild(mt);
        }
        this._undoMemory.pop();
      }
    };


    /**
    *
    * @method HandleInternalEvent
    *
    * This calls one of the provided drawing area events, should a function be assigned to the event requested.
    *
    * @param call:String - the id of the internal event
    * @param params:array - any params associated with the event call
    * @return Void 0
    *
     */

    DrawingArea.prototype.HandleInternalEvent = function(call, params) {
      if (!this._events) {
        return;
      }
      if (!params) {
        params = {};
      }
      if (params.constructor !== Object) {
        params = {
          data: params
        };
      }
      params.targDa = this;
      if (this._events[call]) {
        this._events[call](params);
      }
    };

    DrawingArea.prototype.SlideNav = function(narDir) {
      var ch, cl, clonedImage, currMem, i, j, k, len, len1, len2, memChilden, ref, ref1, ref2;
      this._usingSlidesData[this._currentSlideIndex].Mem = {
        drawCont: this._displayLayers.drawContainer.clone(),
        undo: this._undoMemory.valueOf()
      };
      ref = this._displayLayers.drawContainer.children;
      for (i = 0, len = ref.length; i < len; i++) {
        cl = ref[i];
        memChilden = this._usingSlidesData[this._currentSlideIndex].Mem.drawCont.children;
        if (cl.image) {
          if (cl.image.src.indexOf("data:") === -1) {
            memChilden.push(cl.clone());
          } else {
            clonedImage = new createjs.Bitmap(cl.image.src);
            clonedImage.x = cl.x.valueOf();
            clonedImage.y = cl.y.valueOf();
            memChilden.push(clonedImage);
          }
        } else {
          memChilden.push(cl.clone());
        }
        if (cl.cacheQuality) {
          memChilden[memChilden.length - 1].cacheQuality = cl.cacheQuality;
        }
        cl.uncache();
      }
      this._displayLayers.drawContainer.uncache();
      this._displayLayers.drawContainer.removeAllChildren();
      this._displayLayers.histLayer.image.src = this._managerRef.randomQuery("img/defaults/1x1.png");
      this._undoMemory = [];
      if (narDir === "next") {
        this._currentSlideIndex++;
      } else if (narDir === "previous") {
        this._currentSlideIndex--;
      }
      if (this._usingSlidesData[this._currentSlideIndex].Background && this._usingSlidesData[this._currentSlideIndex].Background !== "") {
        this.ChangeBackground("Slide" + this._currentSlideIndex + "_Background", (function(_this) {
          return function() {
            _this.GetModal("SlideInstruction").Enable();
            return _this.getClonedImage(_this._displayLayers.bgMask.image, function(cImg) {
              return _this._eraseStrokeImage = cImg;
            }, {
              offsetPosition: {
                x: _this._DrawOptions.cropRect[0],
                y: _this._DrawOptions.cropRect[1]
              }
            });
          };
        })(this));
      } else if (this._displayLayers.bgMask) {
        if (this._displayLayers.bgMask.image) {
          this._displayLayers.bgMask.image.src = this._managerRef.randomQuery("img/defaults/blankCanvas.png");
        }
        this._eraseStrokeImage = void 0;
      }
      currMem = this._usingSlidesData[this._currentSlideIndex].Mem;
      if (currMem) {
        ref1 = currMem.drawCont.children;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          cl = ref1[j];
          this._displayLayers.drawContainer.addChild(cl);
        }
        this._undoMemory = currMem.undo;
        ref2 = this._displayLayers.drawContainer.children;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          ch = ref2[k];
          ch.visible = true;
        }
        this.BakeDrawLayers(true, (function(_this) {
          return function() {
            var l, len3, ref3, results;
            ref3 = _this._displayLayers.drawContainer.children;
            results = [];
            for (l = 0, len3 = ref3.length; l < len3; l++) {
              ch = ref3[l];
              results.push(ch.visible = false);
            }
            return results;
          };
        })(this));
      }
      this.GetDaObjectById("Help").Enable();
      if (this._DrawOptions.SlideData) {
        if (this._DrawOptions.SlideData[this._currentSlideIndex].SlideInstruction && this._DrawOptions.SlideData[this._currentSlideIndex].SlideInstruction !== "") {
          if (this._usingSlidesData[this._currentSlideIndex].instructSeen === void 0 || this._usingSlidesData[this._currentSlideIndex].instructSeen === false) {
            this.OpenSlideInstructions();
            this.GetDaObjectById("Help").Disable();
          }
          this.GetDaObjectById("Help").Move(700, 15);
        } else {
          this.GetDaObjectById("Help").Disable();
          this.GetDaObjectById("Help").Move(-1000, 0);
        }
      } else {
        this.GetDaObjectById("Help").Disable();
        this.GetDaObjectById("Help").Move(-1000, 0);
      }
      this.HandleInternalEvent("onSlideOpen");
    };

    DrawingArea.prototype.OpenSlideInstructions = function(contentOveride) {
      var mod, slideDat;
      slideDat = this._usingSlidesData[this._currentSlideIndex];
      if (!slideDat) {
        mod = this.GetModal("intro");
        if (this._walkthroughs.length === 0) {
          mod._buttons[0].Move(300, mod._buttons[0]._container.y);
          mod._buttons[1]._container.visible = false;
        }
        return this.OpenModal("intro");
      } else {
        mod = this.GetModal("SlideInstruction");
        if (this._walkthroughs.length === 0) {
          mod._buttons[0].Move(300, mod._buttons[0]._container.y);
          mod._buttons[1]._container.visible = false;
        }
        if (contentOveride) {
          mod.ChangeContent([
            {
              "text": contentOveride
            }
          ]);
        } else if (slideDat) {
          mod.ChangeContent([
            {
              "text": slideDat.SlideInstruction
            }
          ]);
        }
        if (slideDat.SlideInstructionVO && slideDat.SlideInstructionVO !== "") {
          mod._options.playSound = "Slide" + this._currentSlideIndex + "_vo";
        } else {
          mod._options.playSound = void 0;
        }
        this.OpenModal("SlideInstruction");
        return this._usingSlidesData[this._currentSlideIndex].instructSeen = true;
      }
    };

    return DrawingArea;

  })();

}).call(this);
